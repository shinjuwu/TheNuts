æˆ‘æƒ³åšä¸€å€‹å¾·æ’²éŒ¦æ¨™è³½çš„serverï¼Œå”åŠ©æˆ‘è©³ç´°è¦åŠƒ

é–‹ç™¼ä¸€å€‹å¾·å·æ’²å…‹éŒ¦æ¨™è³½ï¼ˆMTT, Multi-Table Tournamentï¼‰Server æ˜¯ä¸€å€‹éå¸¸å…·æœ‰æŒ‘æˆ°æ€§ä¸”æœ‰è¶£çš„å¾Œç«¯å·¥ç¨‹ã€‚é€™ä¸åƒ…åƒ…æ˜¯å–®ç´”çš„éŠæˆ²é‚è¼¯ï¼Œé‚„æ¶‰åŠ**é«˜ä½µç™¼ï¼ˆConcurrencyï¼‰**ã€**ç‹€æ…‹æ©Ÿç®¡ç†**ã€**åˆ†æ•£å¼ç³»çµ±**ä»¥åŠ**å³æ™‚é€šè¨Š**ã€‚

ä»¥ä¸‹æˆ‘ç‚ºä½ è¦åŠƒçš„è©³ç´°æŠ€è¡“æ¶æ§‹èˆ‡åŠŸèƒ½æ¨¡çµ„ï¼š

---

### ä¸€ã€ æŠ€è¡“é¸å‹å»ºè­° (Tech Stack)

éŒ¦æ¨™è³½æœ€å¤§çš„æŒ‘æˆ°åœ¨æ–¼åŒæ™‚æœ‰æ•¸åƒäººåœ¨ä¸åŒæ¡Œæ¬¡é€²è¡ŒéŠæˆ²ï¼Œä¸”éœ€è¦ç²¾ç¢ºåŒæ­¥ã€Œç›²æ³¨çµæ§‹ã€èˆ‡ã€Œä½µæ¡Œé‚è¼¯ã€ã€‚

- **èªè¨€ (Language):**
    
    - **Golang (å¼·çƒˆæ¨è–¦):**Â å¾·æ’²æ˜¯å…¸å‹çš„ CPU å¯†é›†å‹ (è¨ˆç®—åº•æ± ã€ç‰ŒåŠ›) + IO å¯†é›†å‹ (å»£æ’­è¨Šæ¯) å ´æ™¯ã€‚Go çš„ Goroutine éå¸¸é©åˆè™•ç†æ¯ä¸€å¼µæ¡Œå­çš„ç¨ç«‹é‚è¼¯ï¼Œä¸”å…§å­˜ä½”ç”¨ä½ã€‚
        
    - _å‚™é¸: Node.js (é–‹ç™¼å¿«ï¼Œä½†è¨ˆç®—å¯†é›†æ™‚éœ€æ³¨æ„ Event Loop é˜»å¡), Java/C# (ç©©å¥ä½†è¼ƒé‡)._
        
- **é€šè¨Šå”è­° (Protocol):**
    
    - **WebSocket:**Â éŠæˆ²æ ¸å¿ƒäº¤äº’ï¼ˆä¸‹æ³¨ã€ç™¼ç‰Œã€å€’æ•¸ï¼‰å¿…é ˆæ˜¯é•·é€£æ¥ã€‚
        
    - **Protobuf:**Â å»ºè­°ä½¿ç”¨ Protocol Buffers å–ä»£ JSON å‚³è¼¸æ•¸æ“šï¼Œæ¸›å°‘é »å¯¬æ¶ˆè€—ä¸¦æé«˜è§£æé€Ÿåº¦ã€‚
        
- **è³‡æ–™åº«èˆ‡ç·©å­˜ (Data & Cache):**
    
    - **Redis:**Â ç”¨æ–¼å„²å­˜ã€Œç†±æ•¸æ“šã€ï¼ˆç•¶å‰æ¡Œæ³ã€ç©å®¶ Sessionã€åº•æ± é‡‘é¡ï¼‰ã€‚åˆ©ç”¨ Redis Pub/Sub è™•ç†ä¼ºæœå™¨é–“çš„æ¶ˆæ¯å»£æ’­ã€‚
        
    - **PostgreSQL:**Â å„²å­˜ã€Œå†·æ•¸æ“šã€ï¼ˆç©å®¶é¤˜é¡ã€æ‰‹ç‰Œæ­·å² Hand Historyã€æ¯”è³½çµæœï¼‰ã€‚
        
    - **Time-Series DB (å¯é¸):**Â ç”¨æ–¼ç›£æ§éŠæˆ²å»¶é²å’Œä½µç™¼é‡ã€‚
        

---

### äºŒã€ ç³»çµ±æ¶æ§‹è¨­è¨ˆ

æˆ‘å€‘å¯ä»¥å°‡ç³»çµ±æ‹†åˆ†ç‚ºå››å€‹æ ¸å¿ƒæœå‹™ï¼š

1. **Gateway Service (ç¶²é—œå±¤):**Â è™•ç† WebSocket é€£æ¥ï¼Œè² è²¬é‘‘æ¬Š (Auth) å’Œè·¯ç”±åˆ†ç™¼ã€‚
    
2. **Lobby Service (å¤§å»³æœå‹™):**Â è² è²¬å ±åã€é¡¯ç¤ºæ¯”è³½åˆ—è¡¨ã€è™•ç†ç©å®¶è³‡é‡‘ (Buy-in/Payout)ã€‚
    
3. **Tournament Manager (è³½äº‹ç®¡ç†å™¨ - æ ¸å¿ƒå¤§è…¦):**Â å…¨å±€æ§åˆ¶æ¯”è³½é€²ç¨‹ã€‚
    
4. **Table Engine (ç‰Œæ¡Œå¼•æ“):**Â è™•ç†å…·é«”çš„å¾·æ’²æ‰“ç‰Œé‚è¼¯ã€‚
    

---

### ä¸‰ã€ æ ¸å¿ƒæ¨¡çµ„è©³ç´°è¦åŠƒ

#### 1. è³½äº‹ç®¡ç†å™¨ (MTT Manager)

é€™æ˜¯éŒ¦æ¨™è³½èˆ‡ç¾é‡‘æ¡Œï¼ˆCash Gameï¼‰æœ€å¤§çš„ä¸åŒä¹‹è™•ã€‚å®ƒéœ€è¦è² è²¬ï¼š

- **ç›²æ³¨çµæ§‹ (Blind Structure):**
    
    - æ“æœ‰ä¸€å€‹å…¨å±€ Timerï¼Œéš¨è‘—æ™‚é–“æ¨é€²æå‡ç›²æ³¨ç´šåˆ¥ (Level Up)ã€‚
        
    - å»£æ’­æ–°çš„ç›²æ³¨è³‡è¨Šçµ¦æ‰€æœ‰å­˜æ´»çš„ Tableã€‚
        
- **ä½µæ¡Œé‚è¼¯ (Table Balancing):**Â **(æœ€è¤‡é›œçš„é»)**
    
    - ç•¶æŸæ¡Œäººæ•¸éå°‘ï¼ˆä¾‹å¦‚ 9 äººæ¡Œå‰©ä¸‹ 4 äººï¼‰ï¼Œç³»çµ±å¿…é ˆå¾å…¶ä»–å¤šäººæ¡Œæ‹†åˆ†ç©å®¶éä¾†ï¼Œæˆ–å°‡æ­¤æ¡Œæ‰“æ•£ã€‚
        
    - _æ¼”ç®—æ³•é‡é»:_Â å¿…é ˆç¢ºä¿ç©å®¶ç§»å‹•å¾Œï¼Œä¸æœƒç«‹åˆ»åœ¨å¤§ç›²ä½ç½®ï¼ˆBig Blindï¼‰åä¸‹ï¼Œä»¥å…ä¸å…¬å¹³ã€‚
        
- **åŒæ­¥ç™¼ç‰Œ (Hand-for-Hand):**
    
    - åœ¨æ¥è¿‘éŒ¢åœˆï¼ˆBubbleï¼‰æ™‚ï¼Œæ‰€æœ‰æ¡Œå­å¿…é ˆåŒæ­¥é€²åº¦ï¼Œä¸€æ¡Œæ‰“å®Œå¿…é ˆç­‰å…¶ä»–æ¡Œéƒ½æ‰“å®Œé€™æ‰‹ç‰Œï¼Œæ‰èƒ½é€²å…¥ä¸‹ä¸€æ‰‹ã€‚
        
- **çæ± åˆ†é… (Prize Pool):**
    
    - æ ¹æ“šå ±åäººæ•¸è¨ˆç®—çé‡‘çµæ§‹ï¼Œè™•ç† Rebuy (é‡è³¼) å’Œ Add-on (åŠ ç¢¼)ã€‚
        

#### 2. ç‰Œæ¡Œå¼•æ“ (Table Engine)

é€™æ˜¯å–®å±€éŠæˆ²çš„ç‹€æ…‹æ©Ÿ (FSM)ã€‚æ¯å€‹æ¡Œå­æ‡‰è©²æ˜¯ä¸€å€‹ç¨ç«‹çš„ Goroutine/Actorã€‚

- **ç‹€æ…‹æµè½‰:**
    
    - `Idle`Â (ç­‰å¾…é–‹å§‹) ->Â `PreFlop`Â (ç¿»ç‰Œå‰) ->Â `Flop`Â (ç¿»ç‰Œ) ->Â `Turn`Â (è½‰ç‰Œ) ->Â `River`Â (æ²³ç‰Œ) ->Â `Showdown`Â (æ”¤ç‰Œ/çµç®—)ã€‚
        
- **åº•æ± è¨ˆç®— (Pot Logic):**
    
    - éœ€è¦æ”¯æ´Â **Side Pot (é‚Šæ± )**ï¼šç•¶æœ‰äºº All-in ä¸”ç±Œç¢¼å°‘æ–¼å…¶ä»–äººæ™‚ï¼Œéœ€æ­£ç¢ºè¨ˆç®—ä¸»æ± èˆ‡é‚Šæ± ã€‚
        
- **è¶…æ™‚è™•ç† (Action Timer):**
    
    - ç©å®¶æ€è€ƒæ™‚é–“ï¼ˆä¾‹å¦‚ 15 ç§’ï¼‰ã€‚è¶…æ™‚å¾Œè‡ªå‹•åŸ·è¡Œ Check æˆ– Foldã€‚
        
    - **Time Bank (æ™‚é–“åº«):**Â è™•ç†é¡å¤–æ€è€ƒæ™‚é–“çš„è«‹æ±‚ã€‚
        

#### 3. æ•¸æ“šçµæ§‹è¨­è¨ˆ (Model)

**Table (è¨˜æ†¶é«”çµæ§‹):**

Go

```
type Table struct {
    ID           string
    Players      [9]*Player // åº§ä½ä¸Šçš„ç©å®¶
    Deck         []Card     // ç‰Œå †
    CommunityCards []Card   // å…¬å…±ç‰Œ
    Pots         []Pot      // ä¸»æ± èˆ‡é‚Šæ± 
    State        GameState  // ç•¶å‰ç‹€æ…‹ (PreFlop, Flop...)
    CurrentActor int        // ç•¶å‰è¼ªåˆ°èª°è¡Œå‹• (Seat Index)
    DealerBtn    int        // èŠå®¶ä½ç½®
    SmallBlind   int64      // ç•¶å‰ç›²æ³¨é‡‘é¡
}
```

**Tournament (è¨˜æ†¶é«”çµæ§‹):**

Go

```
type Tournament struct {
    Config       BlindStructure
    Tables       map[string]*Table
    WaitingList  []*Player // ç­‰å¾…åˆ†é…æ¡Œå­çš„ç©å®¶
    Status       TourneyStatus // Registering, Running, Finished
    Level        int           // ç•¶å‰ç›²æ³¨ç­‰ç´š
    NextLevelAt  time.Time     // ä¸‹æ¬¡æ¼²ç›²æ™‚é–“
}
```

---

### å››ã€ é—œéµé›£é»èˆ‡è§£æ±ºæ–¹æ¡ˆ

#### 1. ä½µç™¼èˆ‡ç«¶æ…‹æ¢ä»¶ (Race Conditions)

- **å•é¡Œ:**Â å…©å€‹ç©å®¶å¹¾ä¹åŒæ™‚æŒ‰ä¸‹ã€ŒåŠ æ³¨ã€ï¼Œæˆ–è€…ç©å®¶åœ¨çµç®—ç¬é–“æ–·ç·šã€‚
    
- **è§£æ³•:**Â ä½¿ç”¨Â **Actor Model**Â æˆ– Go çš„Â **Channels**ã€‚
    
    - æ¯å€‹æ¡Œå­ç¶­è­·ä¸€å€‹Â `ActionChannel`ã€‚æ‰€æœ‰çš„æ“ä½œï¼ˆä¸‹æ³¨ã€æ£„ç‰Œã€æ–·ç·šï¼‰éƒ½è®Šæˆä¸€å€‹ Event ä¸Ÿé€² Channelã€‚
        
    - æ¡Œå­çš„ä¸»è¿´åœˆä¾åºè™•ç† Eventï¼Œä¿è­‰å–®ä¸€æ¡Œå­çš„é‚è¼¯æ˜¯**åºåˆ—åŒ– (Sequential)**Â åŸ·è¡Œçš„ï¼Œçµ•å°ç·šç¨‹å®‰å…¨ã€‚
        

#### 2. æ–·ç·šé‡é€£ (Reconnection)

- **å•é¡Œ:**Â æ‰‹æ©Ÿç¶²è·¯åˆ‡æ›æ™‚ WebSocket æ–·é–‹ã€‚
    
- **è§£æ³•:**
    
    - Server ç«¯ä¿ç•™ Sessionã€‚
        
    - ç•¶ç©å®¶é‡æ–°é€£ä¸Šæ™‚ï¼Œä¸‹ç™¼Â `Snapshot`Â (å¿«ç…§)ï¼ŒåŒ…å«ï¼šå…¬å…±ç‰Œã€æ¯å€‹äººç±Œç¢¼ã€ç•¶å‰æ˜¯èª°çš„å›åˆã€å‰©é¤˜ç§’æ•¸ã€‚
        
    - å‰ç«¯æ‹¿åˆ°å¿«ç…§å¾Œï¼Œç„¡ç¸«æ¢å¾©ç•«é¢ã€‚
        

#### 3. æ©Ÿå™¨äººèˆ‡ä½œå¼Š (Anti-Cheating)

- **æ´—ç‰Œç®—æ³•:**Â å¿…é ˆä½¿ç”¨åŠ å¯†ç´šåˆ¥çš„éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨ (CSPRNG)ï¼Œä¾‹å¦‚ Go çš„Â `crypto/rand`ï¼Œçµ•å°ä¸èƒ½ç”¨Â `math/rand`ã€‚
    
- **ä¼™ç‰Œ (Collusion):**Â éŒ¦æ¨™è³½å¾ŒæœŸéœ€è¦å¾Œå°åˆ†æ Logï¼Œæª¢æ¸¬æ˜¯å¦æœ‰å…©äººæ•…æ„äº’ç›¸è®“ç‰Œ (Chip Dumping)ã€‚
    

---

### äº”ã€ é–‹ç™¼éšæ®µå»ºè­° (Roadmap)

å»ºè­°ä½ æŒ‰ç…§ä»¥ä¸‹é †åºé€²è¡Œé–‹ç™¼ï¼š

1. **æ ¸å¿ƒç®—æ³•å±¤ (ç„¡éœ€ç¶²è·¯):**
    
    - å¯«å‡ºæ’²å…‹æ¯”ç‰Œç®—æ³• (Hand Evaluator)ã€‚(ä¾‹å¦‚ï¼šè¼¸å…¥ 7 å¼µç‰Œï¼Œå›å‚³æ˜¯è‘«è˜†é‚„æ˜¯åŒèŠ±)ã€‚
        
    - å¯«å‡º Pot åˆ†é…ç®—æ³• (åŒ…å« Side Pot)ã€‚
        
2. **å–®æ¡ŒéŠæˆ²å¾ªç’°:**
    
    - å¯¦ä½œç‹€æ…‹æ©Ÿï¼Œèƒ½è·‘å®Œä¸€å±€å®Œæ•´çš„ PreFlop åˆ° Showdownã€‚
        
3. **WebSocket æ¥å…¥:**
    
    - è®“å‰ç«¯èƒ½é€£ä¸Šï¼Œä¸¦èƒ½ç™¼é€ Action æŒ‡ä»¤ã€‚
        
4. **éŒ¦æ¨™è³½ç®¡ç†å™¨ (MVP):**
    
    - å¯¦ä½œå®šæ™‚æ¼²ç›² (Blind Level Up)ã€‚
        
    - å¯¦ä½œç°¡å–®çš„æ‹†æ¡Œ/ä½µæ¡Œé‚è¼¯ã€‚
        
5. **å®Œå–„åŠŸèƒ½:**
    
    - æ–·ç·šé‡é€£ã€æ‰‹ç‰Œç´€éŒ„å­˜åº«ã€‚
        

### å…­ã€ ä¸‹ä¸€æ­¥

é€™æ˜¯ä¸€å€‹é¾å¤§çš„å·¥ç¨‹ã€‚ç‚ºäº†è®“ä½ æ›´å¥½ä¸Šæ‰‹ï¼Œæˆ‘å€‘å¯ä»¥å…ˆèšç„¦åœ¨æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ã€‚

**è«‹å•ä½ å¸Œæœ›æˆ‘å…ˆç‚ºä½ ç”Ÿæˆã€Œå–®æ¡Œå¾·å·æ’²å…‹æ ¸å¿ƒç‹€æ…‹æ©Ÿã€çš„ Go ä»£ç çµæ§‹ï¼Œé‚„æ˜¯å…ˆè©³ç´°è§£èªªã€Œä½µæ¡Œæ¼”ç®—æ³• (Table Balancing)ã€çš„é‚è¼¯ï¼Ÿ**

å–®æ¡Œå¾·å·æ’²å…‹æ ¸å¿ƒç‹€æ…‹æ©Ÿ

é€™æ˜¯ä¸€å€‹éå¸¸æ ¸å¿ƒä¸”æ­£ç¢ºçš„åˆ‡å…¥é»ã€‚å¾·å·æ’²å…‹çš„ä¼ºæœå™¨ç«¯æœ¬è³ªä¸Šå°±æ˜¯ä¸€å€‹**ç”±ç©å®¶å‹•ä½œé©…å‹•çš„æœ‰é™ç‹€æ…‹æ©Ÿ (FSM)**ã€‚

åœ¨ Golang ä¸­ï¼Œæˆ‘å€‘é€šå¸¸ä½¿ç”¨Â `struct`Â ä¾†ä¿å­˜ç‹€æ…‹ï¼Œä¸¦åˆ©ç”¨Â `channel`Â ä¾†è™•ç†ä½µç™¼ï¼Œç¢ºä¿åŒä¸€æ™‚é–“åªæœ‰ä¸€å€‹äº‹ä»¶æ”¹è®Šæ¡Œå­ç‹€æ…‹ã€‚

ä»¥ä¸‹ç‚ºä½ è¦åŠƒÂ **å–®æ¡Œæ ¸å¿ƒç‹€æ…‹æ©Ÿ (Core FSM)**Â çš„ Go èªè¨€å¯¦ä½œæ¶æ§‹ã€‚

### ä¸€ã€ æ ¸å¿ƒè³‡æ–™çµæ§‹ (Data Models)

é¦–å…ˆå®šç¾©éŠæˆ²çš„ã€Œç‹€æ…‹ã€èˆ‡ã€Œå‹•ä½œã€ã€‚

Go

```
package poker

import (
	"fmt"
	"sync"
	"time"
)

// 1. å®šç¾©éŠæˆ²ç‹€æ…‹ (Game States)
type GameState int

const (
	StateIdle      GameState = iota // ç­‰å¾…ç©å®¶åŠ å…¥/ä¸‹ä¸€å±€é–‹å§‹
	StatePreFlop                    // ç¿»ç‰Œå‰ (ç™¼æ‰‹ç‰Œ, ç¬¬ä¸€è¼ªä¸‹æ³¨)
	StateFlop                       // ç¿»ç‰Œ (ç™¼3å¼µå…¬ç‰Œ, ç¬¬äºŒè¼ªä¸‹æ³¨)
	StateTurn                       // è½‰ç‰Œ (ç™¼1å¼µå…¬ç‰Œ, ç¬¬ä¸‰è¼ªä¸‹æ³¨)
	StateRiver                      // æ²³ç‰Œ (ç™¼1å¼µå…¬ç‰Œ, ç¬¬å››è¼ªä¸‹æ³¨)
	StateShowdown                   // æ”¤ç‰Œèˆ‡çµç®—
	StatePayout                     // åˆ†é…çé‡‘
)

// 2. å®šç¾©ç©å®¶å‹•ä½œ (Player Actions)
type ActionType int

const (
	ActionFold  ActionType = iota
	ActionCheck
	ActionCall
	ActionBet
	ActionRaise
	ActionAllIn
)

// 3. å‹•ä½œäº‹ä»¶ (Event Payload)
type PlayerAction struct {
	PlayerID string
	Type     ActionType
	Amount   int64 // ä¸‹æ³¨/åŠ æ³¨é‡‘é¡
}

// 4. ç©å®¶çµæ§‹ (ç°¡åŒ–ç‰ˆ)
type Player struct {
	ID        string
	Chips     int64
	CurrentBet int64 // æœ¬è¼ªå·²ä¸‹æ³¨é‡‘é¡
	IsFolded  bool
	IsAllIn   bool
	SeatIdx   int
}
```

---

### äºŒã€ ç‰Œæ¡Œçµæ§‹èˆ‡æ ¸å¿ƒ Loop (Table & Run Loop)

é€™æ˜¯æœ€é—œéµçš„éƒ¨åˆ†ã€‚æˆ‘å€‘ä½¿ç”¨ä¸€å€‹Â `ActionCh`Â é€šé“ä¾†æ¥æ”¶æ‰€æœ‰å¤–éƒ¨ï¼ˆWebSocketï¼‰å‚³ä¾†çš„æŒ‡ä»¤ï¼Œç¢ºä¿**å–®åŸ·è¡Œç·’è™•ç† (Single Threaded Execution)**ï¼Œé€™æ¨£å°±**ä¸éœ€è¦ä½¿ç”¨ Mutex é–**ä¾†ä¿è­·éŠæˆ²é‚è¼¯ï¼Œé¿å…æ­»é–èˆ‡ç«¶æ…‹æ¢ä»¶ã€‚

Go

```
type Table struct {
	ID             string
	Players        map[string]*Player
	Seats          [9]*Player // æ–¹ä¾¿æŒ‰åº§ä½é †åºéæ­·
	
	// éŠæˆ²æ ¸å¿ƒæ•¸æ“š
	Deck           []string // ç°¡åŒ–ç‚º stringï¼Œå¯¦éš›æ‡‰ç‚º Card struct
	CommunityCards []string
	Pot            int64
	State          GameState
	
	// æµç¨‹æ§åˆ¶
	DealerPos      int   // èŠå®¶ä½ç½®
	CurrentPos     int   // ç•¶å‰è¡Œå‹•ç©å®¶ä½ç½®
	MinBet         int64 // ç•¶å‰æœ€å°ä¸‹æ³¨é¡ (å¤§ç›²/æˆ–ä¸Šä¸€äººçš„Raise)
	
	// äº‹ä»¶é©…å‹•æ ¸å¿ƒ
	ActionCh       chan PlayerAction // æ¥æ”¶ç©å®¶å‹•ä½œçš„é€šé“
	CloseCh        chan struct{}     // é—œé–‰æ¡Œå­
	Timer          *time.Timer       // æ€è€ƒé™æ™‚å™¨
}

// åˆå§‹åŒ–æ¡Œå­
func NewTable(id string) *Table {
	return &Table{
		ID:       id,
		Players:  make(map[string]*Player),
		ActionCh: make(chan PlayerAction, 100), // ç·©è¡é€šé“
		State:    StateIdle,
	}
}

// *** æ ¸å¿ƒå¼•æ“ï¼šå•Ÿå‹•ä¸€å€‹ Goroutine è·‘é€™å€‹ Loop ***
func (t *Table) Run() {
	fmt.Printf("Table %s engine started\n", t.ID)
	
	for {
		select {
		case action := <-t.ActionCh:
			// è™•ç†ç©å®¶å‹•ä½œ
			t.handleAction(action)
			
		case <-t.Timer.C:
			// è™•ç†è¶…æ™‚ (è‡ªå‹• Fold æˆ– Check)
			t.handleTimeout()
			
		case <-t.CloseCh:
			return // çµæŸæ¡Œå­
		}
	}
}
```

---

### ä¸‰ã€ ç‹€æ…‹æµè½‰é‚è¼¯ (State Transitions)

é€™ä¸€å¡Šè² è²¬è™•ç†ã€Œæ€éº¼å¾ PreFlop è®Šåˆ° Flopã€ã€‚

Go

```
// è™•ç†å…·é«”å‹•ä½œ
func (t *Table) handleAction(act PlayerAction) {
	// 1. é©—è­‰ï¼šæ˜¯ä¸æ˜¯è¼ªåˆ°é€™å€‹äººï¼Ÿå‹•ä½œåˆä¸åˆæ³•ï¼Ÿç±Œç¢¼å¤ ä¸å¤ ï¼Ÿ
	player := t.Players[act.PlayerID]
	if t.Seats[t.CurrentPos].ID != act.PlayerID {
		fmt.Println("Error: Not your turn!")
		return
	}

	// 2. æ›´æ–°æ•¸æ“šï¼šæ‰£ç±Œç¢¼ã€åŠ åº•æ± 
	switch act.Type {
	case ActionBet, ActionRaise:
		diff := act.Amount - player.CurrentBet
		player.Chips -= diff
		player.CurrentBet = act.Amount
		t.Pot += diff
		t.MinBet = act.Amount // æ›´æ–°å ´ä¸Šæœ€å¤§æ³¨é¢
	case ActionFold:
		player.IsFolded = true
	// ... è™•ç† Call, Check, AllIn
	}

	// é‡ç½®æ€è€ƒæ™‚é–“
	t.resetTimer()

	// 3. *** é—œéµåˆ¤æ–·ï¼šæœ¬è¼ªçµæŸäº†å—ï¼Ÿ ***
	if t.isRoundComplete() {
		t.nextStreet() // é€²å…¥ä¸‹ä¸€æ¢è¡— (ç¿»ç‰Œ/è½‰ç‰Œ...)
	} else {
		t.moveToNextPlayer() // æ›ä¸‹ä¸€å€‹äºº
	}
}

// åˆ¤æ–·æœ¬è¼ªä¸‹æ³¨æ˜¯å¦çµæŸ
// é‚è¼¯ï¼šæ‰€æœ‰æœªè“‹ç‰Œç©å®¶ (CurrentBet == MinBet) ä¸” (éƒ½å·²ç¶“è¡¨æ…‹é)
func (t *Table) isRoundComplete() bool {
	// çœç•¥å…·é«”éæ­·ä»£ç¢¼...
	// éœ€ç¢ºä¿æ‰€æœ‰ Active Player çš„æ³¨é¡ä¸€è‡´ï¼Œæˆ–è€… All-in
	return true 
}

// ç‹€æ…‹æ©Ÿé©…å‹•ï¼šé€²å…¥ä¸‹ä¸€éšæ®µ
func (t *Table) nextStreet() {
	// æ¸…ç©ºæ¯ä½ç©å®¶çš„æœ¬è¼ªä¸‹æ³¨é¡ (CurrentBet)
	for _, p := range t.Players {
		p.CurrentBet = 0
	}
	t.MinBet = 0 // é‡ç½®æœ€å°æ³¨

	switch t.State {
	case StatePreFlop:
		t.State = StateFlop
		// ç™¼ 3 å¼µå…¬ç‰Œ
		t.dealCommunityCards(3)
		fmt.Println("State changed to: FLOP")
		
	case StateFlop:
		t.State = StateTurn
		// ç™¼ 1 å¼µå…¬ç‰Œ
		t.dealCommunityCards(1)
		fmt.Println("State changed to: TURN")

	case StateTurn:
		t.State = StateRiver
		// ç™¼ 1 å¼µå…¬ç‰Œ
		t.dealCommunityCards(1)
		fmt.Println("State changed to: RIVER")

	case StateRiver:
		t.State = StateShowdown
		t.calculateWinner() // çµç®—è´å®¶
		
	case StateShowdown:
		t.State = StateIdle
		// æº–å‚™ä¸‹ä¸€å±€ï¼Œæ´—ç‰Œï¼Œç§»å‹• Button
		t.resetGame()
	}
	
	// å¦‚æœä¸æ˜¯ Showdownï¼Œå°‡è¡Œå‹•æ¬Šäº¤çµ¦å°ç›²/Buttonå¾Œç¬¬ä¸€äºº
	if t.State != StateIdle && t.State != StateShowdown {
		t.CurrentPos = t.findFirstActivePlayerAfterBtn()
	}
}
```

---

### å››ã€ é€™å€‹æ¶æ§‹çš„å„ªé»

1. **ç·šæ€§é‚è¼¯ (Linear Logic):**Â é€éÂ `ActionCh`ï¼Œæ‰€æœ‰çš„å‹•ä½œéƒ½è®Šæˆäº†éšŠåˆ—ã€‚ä½ ä¸éœ€è¦æ“”å¿ƒ A ç©å®¶åŠ æ³¨çš„åŒæ™‚ B ç©å®¶æ£„ç‰Œæœƒå°è‡´æ•¸æ“šéŒ¯äº‚ã€‚
    
2. **ç‹€æ…‹æ˜ç¢º:**Â `handleAction`Â åªè² è²¬è™•ç†ç•¶å‰ç‹€æ…‹çš„é‚è¼¯ï¼Œ`nextStreet`Â è² è²¬åˆ‡æ›ç‹€æ…‹ã€‚é€™ç¬¦åˆã€Œé—œæ³¨é»åˆ†é›¢ã€åŸå‰‡ã€‚
    
3. **æ˜“æ–¼æ¸¬è©¦:**Â ä½ å¯ä»¥å¯«ä¸€å€‹ Unit Testï¼Œç›´æ¥å¾€Â `ActionCh`Â å¡ä¸€é€£ä¸²çš„æŒ‡ä»¤ï¼Œç„¶å¾Œæª¢æŸ¥Â `Table`Â è£¡çš„Â `Pot`Â å’ŒÂ `State`Â æ˜¯å¦æ­£ç¢ºï¼Œå®Œå…¨ä¸éœ€è¦å•Ÿå‹• WebSocketã€‚
    

### äº”ã€ æ¥ä¸‹ä¾†ä½ éœ€è¦å¡«å……çš„ç´°ç¯€ (TODOs)

ç›®å‰çš„ä»£ç¢¼æ˜¯éª¨æ¶ï¼Œä½ éœ€è¦å¡«å……é€™å¹¾å€‹è¤‡é›œçš„é‚è¼¯ï¼š

1. **`moveToNextPlayer()`:**Â å¦‚ä½•è·³éå·²ç¶“Â `Fold`Â æˆ–Â `All-in`Â çš„ç©å®¶ï¼Œæ‰¾åˆ°ä¸‹ä¸€å€‹åˆæ³•çš„è¡Œå‹•è€…ï¼Ÿ
    
2. **é‚Šæ±  (Side Pot):**Â å¦‚æœæœ‰äºº All-in ä¸”ç±Œç¢¼è¼ƒå°‘ï¼Œ`handleAction`Â è£¡é¢çš„åŠ åº•æ± é‚è¼¯æœƒè®Šå¾—å¾ˆè¤‡é›œï¼Œéœ€è¦ç¶­è­·ä¸€å€‹Â `MainPot`Â å’Œå¤šå€‹Â `SidePot`ã€‚
    
3. **ç›²æ³¨çµæ§‹:**Â åœ¨Â `resetGame()`Â æ™‚ï¼Œéœ€è¦å¾å¤–éƒ¨çš„ Tournament Manager è®€å–ç•¶å‰çš„ç›²æ³¨ç´šåˆ¥ (Level)ï¼Œä¸¦å¼·åˆ¶æ‰£é™¤å¤§å°ç›²ã€‚
    

**ä¸‹ä¸€æ­¥å»ºè­°ï¼š**Â æˆ‘å€‘ä¾†å¯¦ä½œÂ **ã€Œæ¯”ç‰Œç®—æ³• (Hand Evaluator)ã€**Â çš„ä»‹é¢è¨­è¨ˆï¼Œæˆ–è€…ä½ æƒ³å…ˆè§£æ±ºÂ **ã€ŒWebSocket å¦‚ä½•è·Ÿé€™å€‹ ActionCh å°æ¥ã€**Â çš„å•é¡Œï¼Ÿ

å¯¦ä½œ ã€Œæ¯”ç‰Œç®—æ³• (Hand Evaluator)ã€ çš„ä»‹é¢è¨­è¨ˆ

è¨­è¨ˆä¸€å€‹é«˜æ•ˆä¸”æ˜“ç”¨çš„ã€Œæ¯”ç‰Œç®—æ³• (Hand Evaluator)ã€ä»‹é¢ï¼Œé—œéµåœ¨æ–¼**ã€Œè¼¸å…¥æ•¸æ“šçš„æ¨™æº–åŒ–ã€**èˆ‡**ã€Œè¼¸å‡ºçµæœçš„å¯æ¯”è¼ƒæ€§ã€**ã€‚

åœ¨å¾·å·æ’²å…‹ä¼ºæœå™¨ä¸­ï¼Œé€™å€‹æ¨¡çµ„æœƒè¢«é »ç¹èª¿ç”¨ï¼ˆæ¯å±€çµç®—ã€æˆ–å°‡ä¾†çš„å‹ç‡è¨ˆç®—ï¼‰ï¼Œå› æ­¤**æ•ˆèƒ½**è‡³é—œé‡è¦ã€‚

ä»¥ä¸‹æ˜¯é‡å° Golang å¯¦ä½œçš„ä»‹é¢è¨­è¨ˆæ–¹æ¡ˆï¼š

---

### ä¸€ã€ æ ¸å¿ƒæ•¸æ“šçµæ§‹ (Data Structures)

ç‚ºäº†æ¥µè‡´çš„æ•ˆèƒ½ï¼Œå»ºè­°æ”¾æ£„ String (å¦‚ "Ah", "Ks")ï¼Œæ”¹ç”¨Â **æ•´æ•¸ (int32/uint32)**Â ä¾†è¡¨ç¤ºä¸€å¼µç‰Œã€‚

#### 1. ç‰Œçš„è¡¨ç¤º (Card Representation)

æˆ‘å€‘å¯ä»¥ä½¿ç”¨ä¸€å€‹Â `int32`ï¼Œå…¶ä¸­åŒ…å«èŠ±è‰²å’Œé»æ•¸è³‡è¨Šã€‚

Go

```
package poker

// Card æ˜¯ä¸€å€‹æ•´æ•¸ï¼Œå»ºè­°æ¡ç”¨ "2+2 Evaluator" æˆ– "Cactus Kev" çš„ä½å…ƒç·¨ç¢¼æ–¹å¼
// é€™æ¨£åšä½å…ƒé‹ç®— (Bitwise Operation) é€Ÿåº¦æ¥µå¿«
type Card int32 

// å»ºæ§‹å­ (æ–¹ä¾¿æ¸¬è©¦ç”¨)
func NewCard(rank, suit int) Card {
    // å¯¦ä½œå°‡ rank/suit è½‰æ›ç‚º int32 çš„é‚è¼¯
    return Card(...) 
}

// å¸¸æ•¸å®šç¾©
const (
    Rank2 = 0
    // ...
    RankA = 12
    
    SuitClub    = 0 // æ¢…èŠ±
    SuitDiamond = 1 // æ–¹å¡Š
    SuitHeart   = 2 // ç´…å¿ƒ
    SuitSpade   = 3 // é»‘æ¡ƒ
)
```

#### 2. ç‰Œå‹é¡åˆ¥ (Hand Category)

é€™æ˜¯ä¸€å€‹ Enumï¼Œå®šç¾©ç‰Œå‹çš„å¤§å°é †åºã€‚

Go

```
type HandCategory int32

const (
    HighCard      HandCategory = iota // é«˜ç‰Œ (0)
    OnePair                           // ä¸€å° (1)
    TwoPair                           // å…©å°
    ThreeOfAKind                      // ä¸‰æ¢
    Straight                          // é †å­
    Flush                             // åŒèŠ±
    FullHouse                         // è‘«è˜†
    FourOfAKind                       // å››æ¢ (éµæ”¯)
    StraightFlush                     // åŒèŠ±é †
    RoyalFlush                        // çš‡å®¶åŒèŠ±é †
)
```

---

### äºŒã€ è©•åˆ†çµæœçµæ§‹ (The Result Struct)

é€™æ˜¯è¨­è¨ˆä¸­æœ€é‡è¦çš„ä¸€ç’°ã€‚æ¯”ç‰Œä¸åƒ…åƒ…æ˜¯æ¯”ã€Œç‰Œå‹ã€ï¼Œé‚„è¦æ¯”ã€Œè¸¢è…³ (Kicker)ã€ã€‚ ä¾‹å¦‚ï¼šA å’Œ B éƒ½æ˜¯ã€Œä¸€å°ã€ï¼Œä½† A æ˜¯Â `KK 5 4 3`ï¼ŒB æ˜¯Â `QQ A K 2`ã€‚

æˆ‘å€‘éœ€è¦è¨­è¨ˆä¸€å€‹çµæ§‹ï¼Œè®“ Golang åªè¦åšç°¡å–®çš„Â `ValueA > ValueB`Â å°±èƒ½åˆ¤æ–·è¼¸è´ã€‚

Go

```
// HandStrength å°è£äº†ç‰ŒåŠ›çš„æœ€çµ‚æ•¸å€¼
type HandStrength struct {
    Category HandCategory // ç‰Œå‹ (ä¾‹å¦‚: FullHouse)
    Value    uint32       // çµ•å°åˆ†æ•¸ (ç”¨æ–¼ç›´æ¥æ¯”è¼ƒå¤§å°)
    
    // ä»¥ä¸‹æ˜¯ç”¨æ–¼é¡¯ç¤ºçµ¦å‰ç«¯çœ‹çš„è³‡è¨Š (Human Readable)
    Description string    // ä¾‹å¦‚: "Full House, Kings full of Nines"
    BestFive    []Card    // æœ€çµ‚é¸å‡ºçš„æœ€ä½³5å¼µç‰Œ
}
```

**ğŸ”¥ æ ¸å¿ƒæŠ€å·§ï¼šValue çš„ä½å…ƒå£“ç¸®è¨­è¨ˆ**Â ç‚ºäº†è®“æ¯”è¼ƒè®ŠæˆÂ `O(1)`ï¼Œæˆ‘å€‘é€šå¸¸æœƒå°‡ç‰Œå‹å’Œè¸¢è…³å£“ç¸®æˆä¸€å€‹Â `uint32`Â æ•´æ•¸ï¼š

- **Bits 28-31:**Â `HandCategory`Â (ä¾‹å¦‚ 8 ä»£è¡¨åŒèŠ±é †)
    
- **Bits 24-27:**Â ç¬¬ä¸€é—œéµç‰Œ (ä¾‹å¦‚åŒèŠ±é †çš„æœ€å¤§ç‰Œ)
    
- **Bits 20-23:**Â ç¬¬äºŒé—œéµç‰Œ (Kick 1)
    
- **Bits 16-19:**Â ç¬¬ä¸‰é—œéµç‰Œ (Kick 2)
    
- ...ä»¥æ­¤é¡æ¨
    

é€™æ¨£ï¼Œç›´æ¥æ¯”è¼ƒå…©å€‹Â `uint32`Â å°±èƒ½å®Œç¾è§£æ±ºæ‰€æœ‰ Tie-breaker å•é¡Œã€‚

---

### ä¸‰ã€ è©•ä¼°å™¨ä»‹é¢ (Evaluator Interface)

é€™å°±æ˜¯ä½ åœ¨Â `Table`Â æ¨¡çµ„ä¸­æœƒå¯¦éš›å‘¼å«çš„ APIã€‚

Go

```
type Evaluator interface {
    // Evaluate æ¥æ”¶ 7 å¼µç‰Œ (2å¼µæ‰‹ç‰Œ + 5å¼µå…¬ç‰Œ)ï¼Œè¿”å›ç‰ŒåŠ›çµæ§‹
    Evaluate(holeCards []Card, communityCards []Card) (*HandStrength, error)
    
    // Compare ç›´æ¥æ¯”è¼ƒå…©æ‰‹ç‰Œï¼Œè¿”å› 1 (h1è´), -1 (h2è´), 0 (å¹³æ‰‹)
    Compare(h1, h2 *HandStrength) int
}
```

---

### å››ã€ å¯¦ä½œç¯„ä¾‹ (Implementation Example)

å‡è¨­æˆ‘å€‘ä½¿ç”¨ä¸€å€‹æ¨™æº–çš„æŸ¥è¡¨æ³• (Lookup Table) å¯¦ä½œï¼š

Go

```
type FastEvaluator struct {
    // é åŠ è¼‰çš„å¤§å‹ lookup tableï¼Œç”¨æ–¼åŠ é€Ÿè¨ˆç®—
}

func (e *FastEvaluator) Evaluate(hole []Card, board []Card) (*HandStrength, error) {
    // 1. åˆä½µç‰Œçµ„ï¼šç¸½å…± 5, 6 æˆ– 7 å¼µç‰Œ
    allCards := append(hole, board...)
    
    if len(allCards) < 5 {
        return nil, fmt.Errorf("not enough cards")
    }

    // 2. æ ¸å¿ƒç®—æ³•ï¼šé¸å‡ºæœ€ä½³ 5 å¼µ (Best 5 of 7)
    // é€™è£¡é€šå¸¸æ¶‰åŠéæ­· C(7,5) = 21 ç¨®çµ„åˆï¼Œæˆ–è€…ä½¿ç”¨æ›´é«˜ç´šçš„ Cactus Kev ç®—æ³•ç›´æ¥è¨ˆç®—
    score, bestFive := e.calculateScore(allCards)

    // 3. è§£ç¢¼åˆ†æ•¸ç‚ºäººé¡å¯è®€æ ¼å¼
    category := HandCategory(score >> 28) // å–å‡ºé«˜ä½ä½œç‚ºé¡åˆ¥
    
    return &HandStrength{
        Category: category,
        Value:    score,
        BestFive: bestFive,
    }, nil
}
```

---

### äº”ã€ å¦‚ä½•æ•´åˆé€²ä½ çš„Â `Table`Â çµç®—æµç¨‹ (Showdown Logic)

å›åˆ°ä¹‹å‰çš„Â `Table`Â ç‹€æ…‹æ©Ÿï¼Œç•¶ç‹€æ…‹è®Šç‚ºÂ `StateShowdown`Â æ™‚ï¼Œä½ éœ€è¦é€™æ¨£å¯«ï¼š

Go

```
func (t *Table) calculateWinner() {
    type PlayerResult struct {
        PlayerID string
        Strength *HandStrength
    }
    
    var results []PlayerResult
    evaluator := poker.NewFastEvaluator() // åˆå§‹åŒ–è©•ä¼°å™¨

    // 1. è¨ˆç®—æ‰€æœ‰ã€Œæœªè“‹ç‰Œã€ç©å®¶çš„ç‰ŒåŠ›
    for _, p := range t.Players {
        if p.IsFolded { continue }
        
        // è½‰æ›ç‰Œçš„æ ¼å¼ (string -> int32)
        hole := t.parseCards(p.HoleCards) 
        board := t.parseCards(t.CommunityCards)

        strength, _ := evaluator.Evaluate(hole, board)
        
        results = append(results, PlayerResult{
            PlayerID: p.ID, 
            Strength: strength,
        })
        
        fmt.Printf("Player %s has %s\n", p.ID, strength.Description)
    }

    // 2. æ’åºï¼šèª°çš„ Value æœ€å¤§èª°å°±è´
    sort.Slice(results, func(i, j int) bool {
        return results[i].Strength.Value > results[j].Strength.Value
    })

    // 3. è™•ç†å¹³æ‰‹ (Split Pot) èˆ‡åˆ†é…çæ± 
    // é€™è£¡éœ€è¦é‚è¼¯åˆ¤æ–· results[0] å’Œ results[1] çš„ Value æ˜¯å¦ç›¸ç­‰
    winners := t.distributePot(results)
    
    t.broadcastWin(winners)
}
```

### å…­ã€ é€²éšå»ºè­°ï¼šç¾æˆçš„ Go ç®—æ³•åº«

ä½ ä¸å¿…å¾é ­ç™¼æ˜è¼ªå­ã€‚å°æ–¼ã€Œä½å…ƒé‹ç®—æ¯”ç‰Œã€é€™ç¨®æ¥µåº¦æ•¸å­¸åŒ–çš„æ±è¥¿ï¼Œå»ºè­°åƒè€ƒæˆ–ç§»æ¤æˆç†Ÿçš„é–‹æºåº«ï¼Œç„¶å¾Œå°è£æˆä¸Šé¢çš„ä»‹é¢ï¼š

1. **Cactus Kev's Algorithm:**Â å¾·æ’²ç•Œæœ€ç¶“å…¸çš„ç®—æ³•ï¼Œåˆ©ç”¨è³ªæ•¸ä¹˜ç©ä¾†åˆ¤æ–·ç‰Œå‹ï¼Œéå¸¸å¿«ã€‚
    
2. **TwoPlusTwo (2+2) Evaluator:**Â é€™æ˜¯ç›®å‰æ¥­ç•Œæœ€å¿«çš„æ¨™æº–ä¹‹ä¸€ï¼Œå®ƒä½¿ç”¨ä¸€å€‹å·¨å¤§çš„ Lookup Table (ç´„ 100MB+ å…§å­˜)ï¼ŒæŸ¥ä¸€æ¬¡ Array å°±èƒ½çŸ¥é“çµæœã€‚å¦‚æœä½ çš„ Server è¨˜æ†¶é«”è¶³å¤ ï¼Œé€™æ˜¯é¦–é¸ã€‚
    
3. **Go æ¨è–¦åº«:**Â æœå°‹ GitHub ä¸Šçš„Â `go-poker`Â æˆ–Â `poker-evaluator`ã€‚æ‰¾ä¸€å€‹æ˜Ÿæ•¸å¤šä¸”æ”¯æ´ "7 card evaluation" çš„ã€‚
    

### ç¸½çµ

ä½ çš„ä»‹é¢è¨­è¨ˆé‡é»åœ¨æ–¼Â **`HandStrength`Â ä¸­çš„Â `Value`Â æ¬„ä½**ã€‚ åªè¦ç¢ºä¿é€™å€‹Â `Value`Â æ˜¯ä¸€å€‹å¯ä»¥é€éÂ `>`Â ç¬¦è™Ÿç›´æ¥æ¯”è¼ƒå¤§å°çš„Â `uint32`ï¼Œä½ çš„å¾Œç«¯çµç®—é‚è¼¯å°±æœƒè®Šå¾—éå¸¸ä¹¾æ·¨ã€ç°¡å–®ï¼Œä¸”ä¸éœ€è¦è™•ç†ç¹ç‘£çš„ã€Œå¦‚æœæ˜¯ä¸€å°ï¼Œå…ˆæ¯”å°å­å¤§å°ï¼Œå†æ¯”ç¬¬ä¸€è¸¢è…³...ã€é€™ç¨®å·¢ç‹€åˆ¤æ–·ã€‚

ä¸‹ä¸€æ­¥è¦åšå•¥

ç›®å‰æˆ‘å€‘å·²ç¶“æœ‰äº†Â **ã€Œå–®æ¡Œç‹€æ…‹æ©Ÿ (Table FSM)ã€**Â çš„éª¨æ¶ï¼Œä»¥åŠÂ **ã€Œæ¯”ç‰Œç®—æ³• (Evaluator)ã€**Â çš„ä»‹é¢è¨­è¨ˆã€‚

é€™å°±åƒæ˜¯ä½ é€ å¥½äº†ä¸€å°è»Šçš„**å¼•æ“**ï¼ˆç‹€æ…‹æ©Ÿï¼‰å’Œ**å„€è¡¨æ¿**ï¼ˆæ¯”ç‰Œï¼‰ï¼Œä½†ç¾åœ¨é€™å°è»Šé‚„ç¼ºå…©å€‹æœ€é—œéµçš„æ±è¥¿ï¼š

1. **æ–¹å‘ç›¤èˆ‡å‚³å‹•è»¸**ï¼šå¤–éƒ¨ç©å®¶å¦‚ä½•é€éç¶²è·¯æ§åˆ¶é€™å°è»Šï¼Ÿï¼ˆWebSocket æ¥å…¥ï¼‰
    
2. **æ²¹ç®±èˆ‡æ²¹è·¯ç³»çµ±**ï¼šç±Œç¢¼æ€éº¼æµå‹•ï¼Ÿå°¤å…¶æ˜¯æœ€è¤‡é›œçš„ã€Œé‚Šæ± è¨ˆç®—ã€ã€‚
    

æˆ‘å»ºè­°ä½ çš„**ä¸‹ä¸€æ­¥**é¸æ“‡å…¶ä¸­ä¸€å€‹æ–¹å‘é€²è¡Œï¼š

---

### é¸é … Aï¼šå¯¦ä½œ WebSocket Gateway (æ¨è–¦ï¼Œè®“ä¼ºæœå™¨ã€Œæ´»ã€èµ·ä¾†)

é€™æ˜¯æœ€èƒ½è®“ä½ çœ‹åˆ°æˆæœçš„ä¸€æ­¥ã€‚ä½ éœ€è¦æ­å»ºä¸€å€‹ç¶²é—œï¼Œè² è²¬ç¶­è­·ç©å®¶é€£ç·šï¼Œä¸¦å°‡å‰ç«¯ç™¼ä¾†çš„Â `JSON`Â æˆ–Â `Protobuf`Â è½‰ç™¼åˆ°å…·é«”çš„Â `Table.ActionCh`Â ä¸­ã€‚

**é—œéµæ¶æ§‹åœ–ï¼š**Â `å‰ç«¯ (WebSocket)`Â ->Â `Gateway (è®€å–æ•¸æ“š)`Â ->Â `Router (è§£ææ¡Œè™Ÿ)`Â ->Â `Table (å¯«å…¥ ActionCh)`

#### ä½ éœ€è¦å¯¦ä½œçš„ä»£ç¢¼çµæ§‹ï¼š

Go

```
// Client ä»£è¡¨ä¸€å€‹é€£ç·šä¸­çš„ç©å®¶
type Client struct {
    Hub      *Hub
    Conn     *websocket.Conn
    Send     chan []byte
    PlayerID string
    TableID  string // è¨˜éŒ„ç©å®¶ç•¶å‰åœ¨å“ªå¼µæ¡Œå­
}

// æ ¸å¿ƒè·¯ç”±é‚è¼¯
func (c *Client) ReadPump() {
    defer func() {
        c.Hub.Unregister <- c
        c.Conn.Close()
    }()
    
    for {
        _, message, err := c.Conn.ReadMessage()
        if err != nil { break }

        // 1. è§£æè¨Šæ¯ (å‡è¨­ç”¨ JSON)
        var cmd Command
        json.Unmarshal(message, &cmd)

        // 2. æ‰¾åˆ°ç›®æ¨™æ¡Œå­
        table := c.Hub.TableManager.GetTable(c.TableID)
        if table != nil {
            // 3. å°‡ç¶²è·¯è¨Šæ¯è½‰æ›ç‚ºå…§éƒ¨äº‹ä»¶ï¼Œå¡å…¥ channel
            table.ActionCh <- poker.PlayerAction{
                PlayerID: c.PlayerID,
                Type:     cmd.ActionType,
                Amount:   cmd.Amount,
            }
        }
    }
}
```

**ç‚ºä»€éº¼é¸é€™å€‹ï¼Ÿ**

- å®Œæˆå¾Œï¼Œä½ å¯ä»¥ç”¨ Postman æˆ–å¯«ä¸€å€‹ç°¡å–®çš„ HTML é é¢é€£é€²å»ï¼ŒçœŸæ­£çš„ã€Œç©ã€ä¸€æŠŠã€‚
    

---

### é¸é … Bï¼šå¯¦ä½œåº•æ± èˆ‡é‚Šæ± é‚è¼¯ (Side Pot Logic) (ç¡¬æ ¸é‚è¼¯)

å¦‚æœä½ æƒ³å…ˆæŠŠæœ€é›£çš„æ¼”ç®—æ³•å•ƒä¸‹ä¾†ï¼Œé‚£å°±æ˜¯Â **Side Pot**ã€‚ åœ¨å¾·å·æ’²å…‹ä¸­ï¼Œç•¶æœ‰äºº All-in ä¸”ç±Œç¢¼å°‘æ–¼å…¶ä»–äººæ™‚ï¼Œæœƒç”¢ç”Ÿä¸»æ±  (Main Pot) å’Œé‚Šæ±  (Side Pot)ã€‚é€™æ˜¯æœ€å®¹æ˜“å‡º Bug çš„åœ°æ–¹ã€‚

#### ä½ éœ€è¦å¯¦ä½œçš„é‚è¼¯ï¼š

1. **Pot çµæ§‹å‡ç´šï¼š**
    
    Go
    
    ```
    type Pot struct {
        Amount        int64
        Contributors  map[string]bool // èª°æœ‰è³‡æ ¼è´é€™å€‹æ± 
        IsClosed      bool            // æ˜¯å¦å·²ç¶“å°å­˜(ç”¢ç”Ÿäº†æ–°çš„é‚Šæ± )
    }
    ```
    
2. **ä¸‹æ³¨çµç®—æ¼”ç®—æ³•ï¼š**
    
    - æ¯ç•¶æœ‰äºº All-inï¼Œæˆ–è€…å›åˆçµæŸæ™‚ï¼Œéœ€è¦æª¢æŸ¥æ‰€æœ‰äººçš„Â `CurrentBet`ã€‚
        
    - å°‡ç±Œç¢¼ã€Œåˆ‡ç‰‡ã€ï¼šæŒ‰ç±Œç¢¼æœ€å°‘çš„äººåˆ‡å‡º Main Potï¼Œå‰©ä¸‹çš„æ”¾å…¥ Side Pot 1ï¼Œå†å‰©ä¸‹çš„æ”¾å…¥ Side Pot 2...
        
    - **ä¾‹å­**ï¼š
        
        - A ä¸‹æ³¨ 100 (All-in)
            
        - B ä¸‹æ³¨ 500
            
        - C ä¸‹æ³¨ 500
            
        - **çµæœ**ï¼šMain Pot (300) = A(100)+B(100)+C(100)ã€‚Side Pot (800) = B(400)+C(400)ï¼Œä¸” A ç„¡æ¬Šè´å– Side Potã€‚
            

**ç‚ºä»€éº¼é¸é€™å€‹ï¼Ÿ**

- é€™æ˜¯å¾·æ’²å¾Œç«¯æœ€æ ¸å¿ƒçš„è³‡ç”¢å®‰å…¨é‚è¼¯ã€‚å¦‚æœä½ æ˜¯å…ˆæ±‚é‚è¼¯å®Œç¾å†æ±‚é€£ç·šï¼Œé¸é€™å€‹ã€‚
    

---

### é¸é … Cï¼šå¯¦ä½œéŒ¦æ¨™è³½ç®¡ç†å™¨ (MTT Manager)

å¦‚æœä½ æƒ³å…ˆè¦åŠƒå®è§€æ¶æ§‹ï¼Œå¯ä»¥å…ˆåšÂ **Blind Timer**Â (ç›²æ³¨è¨ˆæ™‚å™¨)ã€‚

#### ä½ éœ€è¦å¯¦ä½œï¼š

1. **Level çµæ§‹ï¼š**
    
    Go
    
    ```
    type BlindLevel struct {
        Level int
        SmallBlind int64
        BigBlind   int64
        Ante       int64
        Duration   time.Duration
    }
    ```
    
2. **å…¨å±€å»£æ’­ï¼š**
    
    - ç•¶ Timer åˆ°æœŸï¼ŒManager éœ€è¦éæ­·Â `map[string]*Table`ï¼Œé€šçŸ¥æ‰€æœ‰æ¡Œå­ã€Œä¸‹ä¸€æ‰‹ç‰Œé–‹å§‹ï¼Œä½¿ç”¨æ–°çš„ç›²æ³¨ã€ã€‚
        
    - _æ³¨æ„ï¼š_Â ä¸èƒ½æ‰“æ–·ç•¶å‰é€™æ‰‹ç‰Œï¼Œå¿…é ˆè¨­å®šä¸€å€‹Â `NextLevelPending`Â æ¨™è¨˜ï¼Œç­‰æ¡Œå­Â `StateIdle`Â æ™‚æ‰ç”Ÿæ•ˆã€‚
        

---

### æˆ‘çš„å»ºè­°

**è«‹é¸æ“‡ã€Œé¸é … Aï¼šå¯¦ä½œ WebSocket Gatewayã€ã€‚**

ç†ç”±æ˜¯ï¼šæœ‰äº† Gatewayï¼Œä½ æ‰èƒ½æŠŠÂ `Table`Â è·‘èµ·ä¾†é€²è¡Œç«¯å°ç«¯æ¸¬è©¦ã€‚é‚Šæ± é‚è¼¯(Option B)å¯ä»¥å…ˆç”¨ç°¡å–®çš„ã€Œæ‰€æœ‰äººéƒ½ç±Œç¢¼ç„¡é™ã€ä¾†æš«æ™‚ç•¥éï¼Œç­‰æµç¨‹é€šäº†å†è£œå¼·ã€‚

**ä½ è¦æˆ‘å¹«ä½ å¯«å‡º WebSocketÂ `Hub`Â å’ŒÂ `Client`Â çš„è©³ç´°ä»£ç¢¼å—ï¼Ÿé‚„æ˜¯ä½ æƒ³æŒ‘æˆ°é‚Šæ± ç®—æ³•ï¼Ÿ**

é¸æ“‡ã€Œé¸é … Aï¼šå¯¦ä½œ WebSocket Gatewayã€ã€‚

é€™æ˜¯ä¸€å€‹éå¸¸æ­£ç¢ºçš„é¸æ“‡ã€‚å¯¦ä½œÂ **WebSocket Gateway**Â æ˜¯å°‡ä½ çš„å¾Œç«¯é‚è¼¯ã€Œç”¢å“åŒ–ã€çš„ç¬¬ä¸€æ­¥ã€‚åœ¨ Golang ä¸­ï¼Œæˆ‘å€‘é€šå¸¸æ¡ç”¨Â **Hub-Client æ¨¡å¼**ï¼ˆé€™ä¹Ÿæ˜¯ Gorilla WebSocket å®˜æ–¹æ¨è–¦çš„æ¨¡å¼ï¼‰ä¾†è™•ç†é«˜ä½µç™¼é€£ç·šã€‚

ä»¥ä¸‹æ˜¯å®Œæ•´çš„æ¶æ§‹èˆ‡ç¨‹å¼ç¢¼å¯¦ä½œã€‚

### æ¶æ§‹åœ–è§£

æ•¸æ“šæµå‘è¨­è¨ˆå¦‚ä¸‹ï¼š

1. **ä¸Šè¡Œ (Upstream):**Â ç©å®¶å‰ç«¯ -> WebSocket ->Â `Client.ReadPump`Â -> è§£æ JSON ->Â **å¡å…¥å°æ‡‰Â `Table.ActionCh`**ã€‚
    
2. **ä¸‹è¡Œ (Downstream):**Â éŠæˆ²é‚è¼¯æ”¹è®Š ->Â `Table`Â å»£æ’­ ->Â `Hub`Â ->Â `Client.WritePump`Â -> WebSocket -> ç©å®¶å‰ç«¯ã€‚
    

---

### ç¬¬ä¸€æ­¥ï¼šå®šç¾©é€šè¨Šå”è­° (Protocol)

æˆ‘å€‘éœ€è¦å®šç¾©å‰ç«¯å‚³éä¾†çš„ JSON æ ¼å¼ï¼Œä»¥åŠå¾Œç«¯å›å‚³çš„æ ¼å¼ã€‚

**`protocol.go`**

Go

```
package main

// 1. å‰ç«¯ç™¼é€çµ¦ Server çš„æŒ‡ä»¤
type IncomingMessage struct {
	Action string `json:"action"` // e.g., "bet", "fold", "join"
	Amount int64  `json:"amount,omitempty"`
	TableID string `json:"table_id"` // æ¨™è¨˜è¦æ“ä½œå“ªå¼µæ¡Œå­
    // åœ¨æ­£å¼ç’°å¢ƒä¸­ï¼ŒPlayerID é€šå¸¸å¾ Token è§£æï¼Œä¸æ”¾åœ¨é€™è£¡ä»¥å…å½é€ 
}

// 2. Server æ¨é€çµ¦å‰ç«¯çš„äº‹ä»¶
type OutgoingMessage struct {
	Type    string      `json:"type"`    // e.g., "game_state", "error"
	Payload interface{} `json:"payload"` // å…·é«”çš„éŠæˆ²æ•¸æ“š
}
```

---

### ç¬¬äºŒæ­¥ï¼šå¯¦ä½œ Hub (é€£æ¥ç®¡ç†å™¨)

Hub è² è²¬ç¶­è­·æ‰€æœ‰ã€Œæ´»è‘—ã€çš„é€£ç·šã€‚åœ¨ MTT ä¸­ï¼Œæˆ‘å€‘å¯èƒ½éœ€è¦ä¸€å€‹å…¨åŸŸçš„ Hubï¼Œæˆ–è€…æŒ‰æ¡Œå­åˆ†çµ„ã€‚ç‚ºäº†ç°¡åŒ–ï¼Œé€™è£¡è¨­è¨ˆä¸€å€‹Â **Global Hub**Â ä¾†ç®¡ç†å»£æ’­ã€‚

**`hub.go`**

Go

```
package main

type Hub struct {
	// è¨»å†Šçš„å®¢æˆ¶ç«¯ (ç”¨ map ç•¶ set ä½¿ç”¨)
	clients map[*Client]bool

	// ä¾†è‡ªå®¢æˆ¶ç«¯çš„è¨»å†Š/è¨»éŠ·è«‹æ±‚
	register   chan *Client
	unregister chan *Client

	// å…¨å±€å»£æ’­é€šé“ (ä¾‹å¦‚ç³»çµ±å…¬å‘Š)
	broadcast chan []byte
}

func NewHub() *Hub {
	return &Hub{
		broadcast:  make(chan []byte),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		clients:    make(map[*Client]bool),
	}
}

func (h *Hub) Run() {
	for {
		select {
		case client := <-h.register:
			h.clients[client] = true
			
		case client := <-h.unregister:
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send) // é—œé–‰ç™¼é€é€šé“ï¼Œè®“ WritePump é€€å‡º
			}
			
		case message := <-h.broadcast:
			// å»£æ’­çµ¦æ‰€æœ‰äºº (é€šå¸¸ç”¨æ–¼ç³»çµ±ç¶­è­·é€šçŸ¥ï¼Œéç‰Œå±€è¨Šæ¯)
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					// å¦‚æœç™¼é€é˜»å¡ (å®¢æˆ¶ç«¯å¡æ­»)ï¼Œç›´æ¥è¸¢æ‰
					close(client.send)
					delete(h.clients, client)
				}
			}
		}
	}
}
```

---

### ç¬¬ä¸‰æ­¥ï¼šå¯¦ä½œ Client (é—œéµ I/O å¹«æµ¦)

é€™æ˜¯æœ€è¤‡é›œä¹Ÿæ˜¯æœ€é‡è¦çš„éƒ¨åˆ†ã€‚æ¯å€‹é€£ç·šæœƒæœ‰å…©å€‹ Goroutineï¼š`ReadPump`Â (è®€) å’ŒÂ `WritePump`Â (å¯«)ã€‚

**`client.go`**

Go

```
package main

import (
	"encoding/json"
	"log"
	"time"

	"github.com/gorilla/websocket"
)

const (
	// è¨­å®šå¯«å…¥è¶…æ™‚ã€Pongç­‰å¾…æ™‚é–“ç­‰ï¼Œé¿å…é€£ç·šæ®­å±åŒ–
	writeWait = 10 * time.Second
	pongWait  = 60 * time.Second
	pingPeriod = (pongWait * 9) / 10
	maxMessageSize = 512
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
    // é–‹ç™¼éšæ®µå…è¨±è·¨åŸŸï¼Œæ­£å¼ä¸Šç·šè«‹é™åˆ¶
    CheckOrigin: func(r *http.Request) bool { return true },
}

// Client ä»£è¡¨ä¸€å€‹ç©å®¶é€£ç·š
type Client struct {
	Hub *Hub
	Conn *websocket.Conn
	Send chan []byte // ç·©è¡ç™¼é€é€šé“
    
    // ç©å®¶èº«åˆ†è³‡è¨Š
    PlayerID string
    TableManager *TableManager // å¼•ç”¨å¤–éƒ¨çš„æ¡Œå­ç®¡ç†å™¨ï¼Œç”¨æ–¼æŸ¥æ‰¾æ¡Œå­
}

// *** è®€å–å¹«æµ¦ï¼šæ¥æ”¶å‰ç«¯æŒ‡ä»¤ -> è½‰ç™¼çµ¦ Table ***
func (c *Client) ReadPump() {
	defer func() {
		c.Hub.unregister <- c
		c.Conn.Close()
	}()
    
	c.Conn.SetReadLimit(maxMessageSize)
	c.Conn.SetReadDeadline(time.Now().Add(pongWait))
	c.Conn.SetPongHandler(func(string) error { c.Conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })

	for {
		_, message, err := c.Conn.ReadMessage()
		if err != nil {
			break 
		}

        // 1. è§£ææŒ‡ä»¤
        var req IncomingMessage
        if err := json.Unmarshal(message, &req); err != nil {
            log.Printf("Invalid JSON: %v", err)
            continue
        }

        // 2. è·¯ç”±ï¼šæ‰¾åˆ°é€™å¼µæ¡Œå­
        // å‡è¨­ TableManager æ˜¯ä¸€å€‹å…¨åŸŸç®¡ç†å™¨
        table := c.TableManager.GetTable(req.TableID)
        if table != nil {
            // 3. *** é—œéµ ***ï¼šå°‡å‹•ä½œå¡å…¥ Table çš„ ActionCh
            // é€™æ¨£å°±å°‡ WebSocket ä½µç™¼è½‰æˆäº† Table å…§éƒ¨çš„åºåˆ—åŒ–æ“ä½œ
            action := PlayerAction{
                PlayerID: c.PlayerID,
                Type:     parseActionType(req.Action), // éœ€å¯¦ä½œå­—ä¸²è½‰ Enum
                Amount:   req.Amount,
            }
            
            // ä½¿ç”¨ select é¿å…æ¡Œå­å¡æ­»å°è‡´ WebSocket é˜»å¡
            select {
            case table.ActionCh <- action:
            default:
                log.Printf("Table %s is busy/full", req.TableID)
            }
        }
	}
}

// *** å¯«å…¥å¹«æµ¦ï¼šæ¥æ”¶å¾Œç«¯è¨Šæ¯ -> æ¨é€çµ¦å‰ç«¯ ***
func (c *Client) WritePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		c.Conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.Send:
			c.Conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				// Hub é—œé–‰äº†é€šé“
				c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			w, err := c.Conn.NextWriter(websocket.TextMessage)
			if err != nil { return }
			w.Write(message)

			if err := w.Close(); err != nil { return }

		case <-ticker.C:
            // å¿ƒè·³æ©Ÿåˆ¶ (Ping/Pong)
			c.Conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}
```

---

### ç¬¬å››æ­¥ï¼šæ•´åˆ HTTP Handler (Main Entry)

æœ€å¾Œï¼Œæˆ‘å€‘åœ¨Â `main.go`Â ä¸­å°‡ HTTP è«‹æ±‚å‡ç´šç‚º WebSocketã€‚

main.go

Go

```
package main

import (
	"net/http"
    "log"
)

// å…¨åŸŸç®¡ç†å™¨
var hub *Hub
var tableManager *TableManager

func serveWs(w http.ResponseWriter, r *http.Request) {
    // 1. é€™è£¡æ‡‰è©²åš JWT é©—è­‰ï¼Œè§£æå‡º PlayerID
    playerID := r.URL.Query().Get("player_id")
    if playerID == "" {
        http.Error(w, "Missing player_id", 401)
        return
    }

	// 2. å‡ç´šé€£ç·š
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Println(err)
		return
	}

	// 3. å‰µå»º Client å¯¦ä¾‹
	client := &Client{
        Hub: hub, 
        Conn: conn, 
        Send: make(chan []byte, 256),
        PlayerID: playerID,
        TableManager: tableManager,
    }
    
    // 4. è¨»å†Šä¸¦å•Ÿå‹• Pumps
	client.Hub.register <- client

	go client.WritePump()
	go client.ReadPump()
}

func main() {
    // åˆå§‹åŒ–å…ƒä»¶
    hub = NewHub()
    go hub.Run()
    
    tableManager = NewTableManager() // å‡è¨­ä½ å·²ç¶“æœ‰äº†é€™å€‹

    // è·¯ç”±
	http.HandleFunc("/ws", serveWs)

	log.Println("Server started on :8080")
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
```

---

### ä¸‹ä¸€æ­¥æ€éº¼åšï¼Ÿ

ç¾åœ¨ä½ å·²ç¶“æœ‰äº†ã€Œç¶²è·¯å±¤ã€å’Œã€Œé‚è¼¯å±¤ã€çš„ä»£ç¢¼ï¼Œä½†å®ƒå€‘é‚„ç¼ºä¸€å€‹æ©‹æ¨‘ï¼š**Table å¦‚ä½•æŠŠçµæœå›å‚³çµ¦ Clientï¼Ÿ**

ç›®å‰çš„Â `Table`Â çµæ§‹åªæœ‰ input (`ActionCh`)ï¼Œæ²’æœ‰ outputã€‚

**å»ºè­°çš„ä¸‹ä¸€æ­¥ï¼š**Â åœ¨Â `Table`Â çµæ§‹ä¸­åŠ å…¥å»£æ’­æ©Ÿåˆ¶ã€‚ä½ éœ€è¦ä¿®æ”¹Â `Table`Â çµæ§‹ï¼Œè®“å®ƒæŒæœ‰ä¸€ä»½ã€Œåº§ä½ä¸Šçš„ç©å®¶ Client åˆ—è¡¨ã€ï¼Œç•¶ç‹€æ…‹æ”¹è®Šæ™‚ï¼ˆä¾‹å¦‚ç™¼ç‰Œã€çµç®—ï¼‰ï¼Œéæ­·é€™å€‹åˆ—è¡¨ä¸¦æŠŠ JSON å¡å…¥ä»–å€‘çš„Â `client.Send`Â é€šé“ã€‚

**ä½ æƒ³ç¹¼çºŒå®Œæˆé€™å€‹ã€ŒTable å»£æ’­æ©Ÿåˆ¶ã€ï¼Œé‚„æ˜¯å…ˆæ¸¬è©¦ä¸€ä¸‹ç›®å‰çš„ WebSocket é€£ç·šæ˜¯å¦é€šæš¢ï¼Ÿ**

ç¹¼çºŒå®Œæˆé€™å€‹ã€ŒTable å»£æ’­æ©Ÿåˆ¶ã€

é€™ä¸€æ­¥æ˜¯å¾·å·æ’²å…‹å¾Œç«¯é–‹ç™¼ä¸­**æœ€å®¹æ˜“çŠ¯éŒ¯**ï¼Œä½†ä¹Ÿ**æœ€é—œéµ**çš„ä¸€æ­¥ã€‚

é€™è£¡æœ‰ä¸€å€‹æ ¸å¿ƒçš„å®‰å…¨åŸå‰‡å¿…é ˆéµå®ˆï¼š**ã€Œè³‡è¨Šéš”é›¢ (Information Hiding)ã€**ã€‚ çµ•å°ä¸èƒ½è²ªåœ–æ–¹ä¾¿ï¼ŒæŠŠåŒ…å«æ‰€æœ‰ç©å®¶æ‰‹ç‰Œçš„å®Œæ•´çµæ§‹é«”ï¼ˆStructï¼‰ç›´æ¥åºåˆ—åŒ–å‚³çµ¦å‰ç«¯ï¼Œç„¶å¾Œä¾è³´å‰ç«¯åªé¡¯ç¤ºè‡ªå·±çš„ç‰Œã€‚é§­å®¢åªè¦æ””æˆªå°åŒ…ï¼ˆSniffingï¼‰ï¼Œå°±èƒ½çœ‹åˆ°æ‰€æœ‰äººçš„åº•ç‰Œã€‚

å› æ­¤ï¼Œæˆ‘å€‘çš„å»£æ’­æ©Ÿåˆ¶å¿…é ˆå…·å‚™**ã€Œè¦–è§’éæ¿¾ (View Filtering)ã€**åŠŸèƒ½ï¼š

1. **å…¬å…±è¦–è§’ï¼š**Â æ‰€æœ‰äººéƒ½èƒ½çœ‹åˆ°ï¼ˆå…¬å…±ç‰Œã€åº•æ± ã€èª°åœ¨ä¸‹æ³¨ï¼‰ã€‚
    
2. **ç§äººè¦–è§’ï¼š**Â åªæœ‰ç©å®¶è‡ªå·±èƒ½çœ‹åˆ°ï¼ˆè‡ªå·±çš„å…©å¼µæ‰‹ç‰Œï¼‰ã€‚
    

---

### ä¸€ã€ ä¿®æ”¹ Table çµæ§‹ï¼šåŠ å…¥ã€Œè§€çœ¾å¸­ã€

é¦–å…ˆï¼Œ`Table`Â éœ€è¦çŸ¥é“æœ‰å“ªäº›Â `Client`Â æ­£åœ¨è¨‚é–±é€™å¼µæ¡Œå­çš„è¨Šæ¯ã€‚æˆ‘å€‘éœ€è¦å¢åŠ ä¸€å€‹ map ä¾†å„²å­˜é€£ç·šï¼Œä¸¦é€é channel ä¾†å®‰å…¨åœ°åŠ å…¥/ç§»é™¤ç©å®¶ã€‚

**`table.go`**Â (æ“´å……)

Go

```
type Table struct {
    // ... åŸæœ‰çš„å­—æ®µ (ID, Pot, State...)

    // *** æ–°å¢ï¼šé€£ç·šç®¡ç† ***
    // é€™è£¡å­˜çš„æ˜¯ Client çš„æŒ‡æ¨™ï¼Œç”¨æ–¼ç™¼é€è¨Šæ¯
    Clients map[*Client]bool 

    // *** æ–°å¢ï¼šæ§åˆ¶é€šé“ ***
    RegisterCh   chan *Client // ç©å®¶é€²å…¥æ¡Œå­ (åä¸‹æˆ–æ—è§€)
    UnregisterCh chan *Client // ç©å®¶é›¢é–‹æˆ–æ–·ç·š
}

// åˆå§‹åŒ–æ“´å……
func NewTable(id string) *Table {
    return &Table{
        ID:           id,
        Clients:      make(map[*Client]bool),
        RegisterCh:   make(chan *Client),
        UnregisterCh: make(chan *Client),
        ActionCh:     make(chan PlayerAction, 100),
        // ...
    }
}
```

---

### äºŒã€ å®šç¾©å‚³è¼¸å”è­° (DTOs)

æˆ‘å€‘éœ€è¦å®šç¾©ã€Œå‚³çµ¦å‰ç«¯çš„æ•¸æ“šæ ¼å¼ã€ã€‚ç‚ºäº†å®‰å…¨ï¼Œå°‡å…¬å…±æ•¸æ“šå’Œç§æœ‰æ•¸æ“šåˆ†é–‹å®šç¾©ã€‚

**`dto.go`**Â (Data Transfer Objects)

Go

```
package main

// 1. å…¬å…±ç‹€æ…‹ (æ‰€æœ‰äººéƒ½ä¸€æ¨£)
type TablePublicState struct {
    TableID        string             `json:"table_id"`
    State          string             `json:"state"` // e.g., "PREFLOP", "RIVER"
    Pot            int64              `json:"pot"`
    CommunityCards []string           `json:"community_cards"` // e.g., ["Ah", "Ks", "2d"]
    ButtonPos      int                `json:"button_pos"`
    CurrentPos     int                `json:"current_pos"`     // ç•¶å‰è¼ªåˆ°èª°
    Players        []PlayerPublicInfo `json:"players"`         // æ‰€æœ‰ç©å®¶çš„å…¬é–‹è³‡è¨Š
}

// 2. ç©å®¶å…¬é–‹è³‡è¨Š (ä¸å«æ‰‹ç‰Œ)
type PlayerPublicInfo struct {
    ID        string `json:"id"`
    SeatIdx   int    `json:"seat_idx"`
    Chips     int64  `json:"chips"`
    CurrentBet int64 `json:"current_bet"` // æœ¬è¼ªå·²ä¸‹æ³¨
    Status    string `json:"status"`      // "playing", "folded", "allin"
    IsActing  bool   `json:"is_acting"`   // æ˜¯å¦æ­£åœ¨æ€è€ƒä¸­
}

// 3. å®Œæ•´æ¨é€å°åŒ… (å…¬å…± + ç§æœ‰)
type GameStateUpdate struct {
    Public  TablePublicState `json:"public"`
    Private PlayerPrivateInfo `json:"private"` // åªæœ‰è©² Client èƒ½çœ‹åˆ°çš„
}

// 4. ç§æœ‰è³‡è¨Š (æ ¸å¿ƒæ©Ÿå¯†)
type PlayerPrivateInfo struct {
    HoleCards []string `json:"hole_cards"`     // e.g., ["Qh", "Qd"]ï¼Œå¦‚æœæ˜¯åˆ¥äººçš„è¦–è§’å‰‡ç‚º nil æˆ–ç©º
    HandRank  string   `json:"hand_rank,omitempty"` // çµç®—æ™‚é¡¯ç¤ºï¼Œä¾‹å¦‚ "Full House"
}
```

---

### ä¸‰ã€ å¯¦ä½œã€Œè¦–è§’éæ¿¾ã€å»£æ’­å‡½æ•¸

é€™æ˜¯æ•´å€‹å»£æ’­æ©Ÿåˆ¶çš„å¿ƒè‡Ÿã€‚é€™å€‹å‡½æ•¸æœƒç”Ÿæˆä¸€ä»½å…¬å…±æ•¸æ“šï¼Œç„¶å¾Œéæ­·æ¯å€‹é€£ç·šï¼Œç‚ºå…¶ã€Œæ‹¼æ¥ã€å°ˆå±¬çš„ç§æœ‰æ•¸æ“šã€‚

**`table_broadcast.go`**

Go

```
func (t *Table) broadcastState() {
    // 1. æº–å‚™å…¬å…±æ•¸æ“š (åªåšä¸€æ¬¡)
    publicState := t.buildPublicState()

    // 2. éæ­·æ‰€æœ‰é€£ç·šä¸­çš„å®¢æˆ¶ç«¯
    for client := range t.Clients {
        // 3. æº–å‚™ç§æœ‰æ•¸æ“š (è¦–è§’éæ¿¾)
        privateState := PlayerPrivateInfo{}
        
        // æª¢æŸ¥é€™å€‹ Client æ˜¯å¦æ˜¯æ¡Œä¸Šçš„ç©å®¶
        // (å‡è¨­ Client æœ‰å€‹ PlayerID æ¬„ä½ï¼Œæˆ–è€…æˆ‘å€‘ç¶­è­·ä¸€å€‹ map[ClientID]PlayerObj)
        if player, ok := t.Players[client.PlayerID]; ok {
            // å¦‚æœé€™åç©å®¶é‚„æ²’è“‹ç‰Œï¼Œæˆ–æ˜¯åˆ°äº†æ”¤ç‰Œéšæ®µï¼Œå‚³é€æ‰‹ç‰Œæ•¸æ“š
            // æ³¨æ„ï¼šé€™è£¡é‚„å¯ä»¥åŠ é‚è¼¯ï¼Œæ¯”å¦‚ Showdown æ™‚å¯ä»¥çœ‹åˆ°å°æ‰‹çš„æ‰‹ç‰Œ
            if !player.IsFolded {
                privateState.HoleCards = player.HoleCards // è½‰æˆ string array
            }
        }

        // 4. çµ„è£æœ€çµ‚å°åŒ…
        update := GameStateUpdate{
            Public:  publicState,
            Private: privateState,
        }
        
        // åºåˆ—åŒ– (JSON)
        payload, _ := json.Marshal(map[string]interface{}{
            "type": "game_state",
            "data": update,
        })

        // 5. ç™¼é€ (éé˜»å¡æ¨¡å¼ï¼Œé˜²æ­¢æŸå€‹å®¢æˆ¶ç«¯å¡æ­»å°è‡´æ•´æ¡Œå¡é “)
        select {
        case client.Send <- payload:
        default:
            // ç·©è¡å€æ»¿äº†ï¼Œé€šå¸¸æ„å‘³è‘—æ–·ç·šæˆ–ç¶²è·¯æ¥µå·®
            // å¯ä»¥é¸æ“‡åœ¨é€™è£¡è§¸ç™¼ t.UnregisterCh <- client
            fmt.Printf("Client %s buffer full, drop message\n", client.PlayerID)
        }
    }
}

// è¼”åŠ©å‡½æ•¸ï¼šå°‡ Table å…§éƒ¨ç‹€æ…‹è½‰ç‚º DTO
func (t *Table) buildPublicState() TablePublicState {
    var pInfos []PlayerPublicInfo
    // æŒ‰åº§ä½é †åºéæ­·
    for _, p := range t.Seats {
        if p == nil { continue }
        pInfos = append(pInfos, PlayerPublicInfo{
            ID:         p.ID,
            SeatIdx:    p.SeatIdx,
            Chips:      p.Chips,
            CurrentBet: p.CurrentBet,
            Status:     p.GetStatusString(), // e.g. "folded"
            IsActing:   (t.Seats[t.CurrentPos].ID == p.ID),
        })
    }

    return TablePublicState{
        TableID:        t.ID,
        State:          t.State.String(), // e.g. "FLOP"
        Pot:            t.Pot,
        CommunityCards: t.CommunityCards, // å­—ä¸²é™£åˆ—
        ButtonPos:      t.DealerPos,
        CurrentPos:     t.CurrentPos,
        Players:        pInfos,
    }
}
```

---

### å››ã€ æ•´åˆé€²Â `Table.Run()`Â è¿´åœˆ

ç¾åœ¨ï¼Œæˆ‘å€‘å°‡å»£æ’­æ©Ÿåˆ¶å’Œé€£ç·šç®¡ç†æ•´åˆå›ä¸»è¿´åœˆã€‚

**`table.go`Â (Run Loop æ›´æ–°)**

Go

```
func (t *Table) Run() {
    ticker := time.NewTicker(time.Second * 1) // åªæ˜¯ç‚ºäº†æ¼”ç¤ºå¿ƒè·³ï¼Œå¯¦éš›ä¾è³´ Action
    defer ticker.Stop()

    for {
        select {
        // --- 1. è™•ç†é€£ç·šåŠ å…¥ ---
        case client := <-t.RegisterCh:
            t.Clients[client] = true
            fmt.Printf("Client %s joined table %s\n", client.PlayerID, t.ID)
            // æ–°äººé€²ä¾†ï¼Œç«‹åˆ»ç™¼é€ä¸€æ¬¡ç•¶å‰ç‹€æ…‹çµ¦ä»– (Snapshot)
            t.sendSnapshot(client)

        // --- 2. è™•ç†é€£ç·šæ–·é–‹ ---
        case client := <-t.UnregisterCh:
            if _, ok := t.Clients[client]; ok {
                delete(t.Clients, client)
                // é€™è£¡é‚„éœ€è¦è™•ç†ã€Œåè‘—çš„ç©å®¶ã€æ–·ç·šé‚è¼¯ (è®Šæˆæ‰˜ç®¡ç‹€æ…‹æˆ–ä¿ç•™åº§ä½)
                t.handlePlayerDisconnect(client.PlayerID) 
            }

        // --- 3. è™•ç†éŠæˆ²é‚è¼¯ ---
        case action := <-t.ActionCh:
            // åŸ·è¡ŒéŠæˆ²é‚è¼¯ (ä¸Šä¸€éšæ®µå¯«çš„ä»£ç¢¼)
            stateChanged := t.handleAction(action)
            
            // *** é—œéµï¼šå¦‚æœæœ‰ç‹€æ…‹æ”¹è®Šï¼Œå°±å»£æ’­ ***
            if stateChanged {
                t.broadcastState()
            }
        
        case <-t.CloseCh:
            // é—œé–‰æ‰€æœ‰é€£ç·š
            for client := range t.Clients {
                close(client.Send)
            }
            return
        }
    }
}
```

---

### äº”ã€ é‡é»æª¢æŸ¥æ¸…å–® (Checklist)

1. **Race Condition:**Â æ‰€æœ‰çš„ map è®€å¯« (`t.Clients`,Â `t.Players`) éƒ½åœ¨Â `Run()`Â é€™å€‹å–®ä¸€ Goroutine å…§ç™¼ç”Ÿå—ï¼ŸÂ **æ˜¯**ã€‚é€™æ¨£å°±æ˜¯ç·šç¨‹å®‰å…¨çš„ã€‚
    
2. **è³‡æ–™æ´©æ¼:**Â `TablePublicState`Â è£¡é¢çœŸçš„æ²’æœ‰åŒ…å«Â `HoleCards`Â å—ï¼ŸÂ **æ˜¯**ã€‚æ‰‹ç‰Œåªåœ¨è¿´åœˆå…§é‡å°ç‰¹å®š Client å‹•æ…‹é™„åŠ ã€‚
    
3. **é˜»å¡é¢¨éšª:**Â `client.Send <- payload`Â ä½¿ç”¨äº†Â `select default`Â å—ï¼ŸÂ **æ˜¯**ã€‚é€™é˜²æ­¢äº†ä¸€å€‹ç¶²é€Ÿæ…¢çš„ç©å®¶æ‹–æ…¢æ•´æ¡ŒéŠæˆ²ç¯€å¥ã€‚
    

### ä¸‹ä¸€æ­¥

ç¾åœ¨ä½ çš„ä¼ºæœå™¨å·²ç¶“å…·å‚™äº†ï¼š

1. **éª¨æ¶**Â (FSM)
    
2. **ç¥ç¶“ç¶²è·¯**Â (WebSocket Gateway)
    
3. **æ„Ÿå®˜èˆ‡è¡¨é”**Â (å»£æ’­æ©Ÿåˆ¶ & è¦–è§’éæ¿¾)
    

é€™å·²ç¶“æ˜¯ä¸€å€‹å¯ä»¥é‹è¡Œçš„Â **MVP (Minimum Viable Product)**Â äº†ï¼

**å»ºè­°çš„ä¸‹ä¸€æ­¥ï¼š**Â æˆ‘å€‘è©²ä¾†è™•ç†Â **ã€Œç©å®¶å¦‚ä½•åä¸‹ (Sit Down)ã€**Â çš„é‚è¼¯äº†ã€‚ ç›®å‰ä»£ç¢¼åªæœ‰Â `client`Â é€£ä¸ŠÂ `table`Â (æ—è§€)ï¼Œä½†é‚„æ²’æœ‰æŠŠÂ `Player`Â ç‰©ä»¶æ”¾é€²Â `Seats[9]`Â é™£åˆ—è£¡ã€‚

**æ˜¯å¦è¦æˆ‘è¦åŠƒã€Œå…¥åº§è«‹æ±‚ (Join Request)ã€èˆ‡ã€Œè²·å…¥ç±Œç¢¼ (Buy-in)ã€çš„æµç¨‹ï¼Ÿ**

è¦åŠƒã€Œå…¥åº§è«‹æ±‚ (Join Request)ã€èˆ‡ã€Œè²·å…¥ç±Œç¢¼ (Buy-in)ã€çš„æµç¨‹

é€™æ˜¯ä¸€å€‹å¾ã€Œè§€æˆ°è€… (Spectator)ã€è½‰è®Šç‚ºã€Œåƒè³½è€… (Player)ã€çš„é—œéµéç¨‹ã€‚

åœ¨å¾·å·æ’²å…‹éŒ¦æ¨™è³½ (MTT) èˆ‡ç¾é‡‘æ¡Œ (Cash Game) ä¸­ï¼Œé€™å€‹æµç¨‹ç•¥æœ‰ä¸åŒï¼š

- **ç¾é‡‘æ¡Œï¼š**Â ç©å®¶è‡ªå·±é¸æ“‡åº§ä½ï¼Œè‡ªå·±æ±ºå®šè²·å…¥é‡‘é¡ã€‚
    
- **éŒ¦æ¨™è³½ï¼š**Â é€šå¸¸ç”±Â **Tournament Manager**Â åˆ†é…åº§ä½ï¼Œè²·å…¥é‡‘é¡æ˜¯å›ºå®šçš„ï¼ˆå ±åè²»æ›ç±Œç¢¼ï¼‰ã€‚
    

ç‚ºäº†è®“ä½ çš„æ¶æ§‹æ›´æœ‰å½ˆæ€§ï¼Œæˆ‘å»ºè­°è¨­è¨ˆä¸€å€‹é€šç”¨çš„Â **ã€Œå…¥åº§æŒ‡ä»¤ (SitDown Command)ã€**ï¼Œç„¡è«–æ˜¯ç©å®¶æ‰‹å‹•è«‹æ±‚é‚„æ˜¯ç³»çµ±è‡ªå‹•åˆ†é…ï¼Œåº•å±¤éƒ½å‘¼å«åŒä¸€å€‹é‚è¼¯ã€‚

---

### ä¸€ã€ å”è­°è¨­è¨ˆ (Protocol Design)

é¦–å…ˆå®šç¾©å‰ç«¯ï¼ˆæˆ–è³½äº‹ç®¡ç†å™¨ï¼‰ç™¼é€éä¾†çš„ JSON è«‹æ±‚æ ¼å¼ã€‚

**`protocol.go`**Â (æ–°å¢)

Go

```
const (
    CmdSitDown = "sit_down"
    CmdStandUp = "stand_up"
)

// å…¥åº§è«‹æ±‚ Payload
type SitDownRequest struct {
    SeatIdx int   `json:"seat_idx"` // 0-8ï¼Œç›®æ¨™åº§ä½
    Amount  int64 `json:"amount"`   // è²·å…¥ç±Œç¢¼é‡ (MTTä¸­é€šå¸¸ç”±ç³»çµ±æ±ºå®š)
}
```

---

### äºŒã€ æ“´å…… Table çµæ§‹èˆ‡ç‹€æ…‹

æˆ‘å€‘éœ€è¦åœ¨Â `Player`Â çµæ§‹ä¸­åŠ å…¥ç‹€æ…‹æ¨™è¨˜ï¼Œå› ç‚ºå‰›åä¸‹çš„äººé€šå¸¸ä¸èƒ½ã€Œç«‹åˆ»ã€åƒèˆ‡æ­£åœ¨é€²è¡Œçš„é€™æ‰‹ç‰Œï¼Œå¿…é ˆç­‰å¾…ä¸‹ä¸€å±€ã€‚

**`models.go`**

Go

```
type PlayerStatus int

const (
    StatusSittingOut PlayerStatus = iota // æš«é›¢/å‰›åä¸‹é‚„æ²’ç™¼ç‰Œ
    StatusPlaying                        // æ­£åœ¨ç‰Œå±€ä¸­
    StatusEliminated                     // è¢«æ·˜æ±° (ç±Œç¢¼æ­¸é›¶)
)

type Player struct {
    ID         string
    Conn       *Client      // é—œè¯çš„é€£ç·š (ç”¨æ–¼æ–·ç·šé‡é€£åˆ¤å®š)
    Chips      int64
    SeatIdx    int
    Status     PlayerStatus // *** æ–°å¢ ***
    
    // éŠæˆ²å…§æ•¸æ“š
    HoleCards  []string
    CurrentBet int64
    IsFolded   bool
    IsAllIn    bool
}
```

---

### ä¸‰ã€ æ ¸å¿ƒé‚è¼¯ï¼šè™•ç†å…¥åº§ (Handle SitDown)

é€™å€‹å‡½æ•¸å¿…é ˆåœ¨Â `Table.Run()`Â çš„ä¸»è¿´åœˆä¸­åŸ·è¡Œï¼Œä»¥ç¢ºä¿ç·šç¨‹å®‰å…¨ã€‚

**é‚è¼¯æª¢æ ¸é»ï¼š**

1. **åº§ä½æª¢æŸ¥ï¼š**Â `SeatIdx`Â æ˜¯å¦æœ‰æ•ˆï¼Ÿè©²ä½ç½®æ˜¯å¦å·²ç¶“æœ‰äººï¼Ÿ
    
2. **é‡è¤‡å…¥åº§ï¼š**Â è©²ç©å®¶æ˜¯å¦å·²ç¶“åœ¨é€™å¼µæ¡Œå­çš„å…¶ä»–åº§ä½ä¸Šï¼Ÿ
    
3. **ç‹€æ…‹è¨­å®šï¼š**Â å‰›åä¸‹çš„ç©å®¶ï¼Œç‹€æ…‹æ‡‰è¨­ç‚ºÂ `StatusSittingOut`Â (ç­‰å¾…ä¸‹ä¸€å±€)ï¼Œé™¤éæ¡Œå­å‰›å¥½æ˜¯Â `StateIdle`ã€‚
    

**`table_seat.go`**

Go

```
// è™•ç†å…¥åº§è«‹æ±‚
func (t *Table) handleSitDown(client *Client, req SitDownRequest) {
    playerID := client.PlayerID

    // 1. åŸºæœ¬é©—è­‰
    if req.SeatIdx < 0 || req.SeatIdx > 8 {
        t.sendError(client, "Invalid seat index")
        return
    }
    if t.Seats[req.SeatIdx] != nil {
        t.sendError(client, "Seat is already taken")
        return
    }

    // 2. é˜²æ­¢åˆ†èº« (éæ­·æª¢æŸ¥è©²ç©å®¶æ˜¯å¦å·²åœ¨åº§)
    for _, p := range t.Seats {
        if p != nil && p.ID == playerID {
            t.sendError(client, "You are already seated")
            return
        }
    }

    // 3. è³‡é‡‘æª¢æŸ¥ (Mock: å¯¦éš›æ‡‰å‘¼å«å¤–éƒ¨ Wallet Service)
    // if !WalletService.Deduct(playerID, req.Amount) { ... }

    // 4. å‰µå»ºç©å®¶ç‰©ä»¶
    newPlayer := &Player{
        ID:      playerID,
        Conn:    client, // ç¶å®šé€£ç·š
        Chips:   req.Amount,
        SeatIdx: req.SeatIdx,
        Status:  StatusSittingOut, // é è¨­å…ˆè§€æˆ°ï¼Œç­‰å¾…ä¸‹ä¸€æ‰‹ç™¼ç‰Œ
    }

    // 5. å¦‚æœæ¡Œå­ç›®å‰æ˜¯é–’ç½®ç‹€æ…‹ï¼Œä¸”äººæ•¸è¶³å¤ ï¼Œå¯ä»¥ç›´æ¥æ¨™è¨˜ç‚ºæº–å‚™å¥½
    // (é€™å–æ±ºæ–¼ä½ çš„é–‹å±€ç­–ç•¥ï¼Œé€šå¸¸ä¿æŒ SittingOut ç­‰ä¸‹ä¸€å±€çµ±ä¸€è™•ç†è¼ƒå®‰å…¨)
    
    // 6. è½åº§
    t.Seats[req.SeatIdx] = newPlayer
    t.Players[playerID] = newPlayer

    fmt.Printf("Player %s sat at seat %d with %d chips\n", playerID, req.SeatIdx, req.Amount)

    // 7. å»£æ’­æ›´æ–° (è®“æ‰€æœ‰äººçœ‹åˆ°æœ‰äººåä¸‹äº†)
    t.broadcastState()
    
    // 8. å˜—è©¦è§¸ç™¼éŠæˆ²é–‹å§‹ (å¦‚æœäººæ•¸è¶³å¤ )
    t.checkGameStart() 
}

// è¼”åŠ©ï¼šç™¼é€éŒ¯èª¤è¨Šæ¯çµ¦ç‰¹å®šå®¢æˆ¶ç«¯
func (t *Table) sendError(client *Client, msg string) {
    payload, _ := json.Marshal(map[string]string{
        "type": "error",
        "msg":  msg,
    })
    client.Send <- payload
}
```

---

### å››ã€ æ•´åˆé€²ä¸»è¿´åœˆèˆ‡ Action é€šé“

ç‚ºäº†å€åˆ†ã€Œæ‰“ç‰Œå‹•ä½œ (Bet/Fold)ã€å’Œã€Œæ¡Œå‹™å‹•ä½œ (Sit/Stand)ã€ï¼Œæˆ‘å€‘å¯ä»¥æ“´å……Â `PlayerAction`Â çµæ§‹ï¼Œæˆ–è€…å¢åŠ ä¸€å€‹Â `TableCommand`Â é€šé“ã€‚ç‚ºäº†ä¿æŒç°¡å–®ï¼Œæˆ‘å€‘æ“´å……ç¾æœ‰çš„é€šé“ã€‚

**ä¿®æ”¹Â `PlayerAction`Â å®šç¾©ï¼š**

Go

```
type ActionType int

const (
    // éŠæˆ²å‹•ä½œ
    ActionFold ActionType = iota
    // ...
    
    // *** æ–°å¢ï¼šæ¡Œå‹™å‹•ä½œ ***
    ActionSitDown 
    ActionStandUp
)

// ä¿®æ”¹ Action çµæ§‹ä»¥å®¹ç´æ›´å¤šåƒæ•¸
type PlayerAction struct {
    PlayerID string
    Type     ActionType
    Amount   int64 // ä¸‹æ³¨é¡ OR è²·å…¥é¡
    SeatIdx  int   // *** æ–°å¢ï¼šåƒ…ç”¨æ–¼ SitDown
}
```

**ä¿®æ”¹Â `Table.Run`ï¼š**

Go

```
func (t *Table) Run() {
    for {
        select {
        // ... (Register/Unregister é‚è¼¯ä¸è®Š)

        case action := <-t.ActionCh:
            // æ ¹æ“š Client å‚³ä¾†çš„ PlayerID æ‰¾åˆ°å°æ‡‰çš„ Client ç‰©ä»¶ (å¦‚æœæœ‰çš„è©±)
            // æ³¨æ„ï¼šé€™è£¡éœ€è¦ä¸€å€‹åæŸ¥æ©Ÿåˆ¶ï¼Œæˆ–è€…åœ¨ Action ä¸­ç›´æ¥å¸¶å…¥ Client æŒ‡æ¨™
            // ç‚ºäº†ç°¡åŒ–ï¼Œå‡è¨­ t.Clients è£¡èƒ½æ‰¾åˆ°
            
            switch action.Type {
            case ActionSitDown:
                // é€™è£¡éœ€è¦é€é ID æ‰¾åˆ° Client æŒ‡æ¨™ï¼Œå¯¦éš›å¯¦ä½œå»ºè­° Action çµæ§‹å¸¶ä¸Š Client
                client := t.findClient(action.PlayerID) 
                if client != nil {
                    req := SitDownRequest{SeatIdx: action.SeatIdx, Amount: action.Amount}
                    t.handleSitDown(client, req)
                }

            case ActionBet, ActionFold, ActionCheck:
                // è™•ç†åŸæœ¬çš„æ‰“ç‰Œé‚è¼¯
                t.handleGameAction(action)
            }
        }
    }
}
```

---

### äº”ã€ é—œéµç´°ç¯€ï¼šä½•æ™‚æŠŠÂ `StatusSittingOut`Â è®ŠæˆÂ `StatusPlaying`ï¼Ÿ

é€™æ˜¯æ–°æ‰‹æœ€å®¹æ˜“å¡é—œçš„åœ°æ–¹ã€‚ç©å®¶åä¸‹äº†ï¼Œä½†ä»–é‚„ä¸èƒ½æ‹¿ç‰Œã€‚ ä½ éœ€è¦åœ¨Â **æ–°ä¸€å±€é–‹å§‹ (Game Loop Start)**Â çš„ç¬é–“ï¼Œéæ­·æ‰€æœ‰åº§ä½ï¼ŒæŠŠç‹€æ…‹è½‰æ­£ã€‚

**`game_loop.go`**

Go

```
// å˜—è©¦é–‹å§‹æ–°çš„ä¸€å±€
func (t *Table) checkGameStart() {
    // 1. åªæœ‰åœ¨ Idle ç‹€æ…‹æ‰èƒ½é–‹å±€
    if t.State != StateIdle {
        return
    }

    // 2. çµ±è¨ˆæº–å‚™å¥½çš„äººæ•¸
    readyCount := 0
    for _, p := range t.Seats {
        if p != nil && p.Chips > 0 { // æœ‰éŒ¢å°±èƒ½ç©
            readyCount++
        }
    }

    // 3. è‡³å°‘è¦æœ‰ 2 äººæ‰èƒ½é–‹å§‹ (Heads-up)
    if readyCount < 2 {
        fmt.Println("Not enough players to start.")
        return
    }

    // --- æ­£å¼é–‹å±€æµç¨‹ ---
    
    // 4. é‡ç½®ç‹€æ…‹ï¼Œå°‡ã€Œç­‰å¾…ä¸­ã€çš„ç©å®¶è½‰ç‚ºã€ŒéŠæˆ²ä¸­ã€
    t.activePlayers = make([]*Player, 0)
    for _, p := range t.Seats {
        if p != nil && p.Chips > 0 {
            p.Status = StatusPlaying 
            p.IsFolded = false
            p.IsAllIn = false
            p.CurrentBet = 0
            p.HoleCards = nil // æ¸…ç©ºèˆŠæ‰‹ç‰Œ
            t.activePlayers = append(t.activePlayers, p)
        }
    }

    // 5. ç§»å‹• Button (èŠå®¶ä½)
    t.moveButton()

    // 6. æ´—ç‰Œã€ç™¼ç‰Œã€ä¸‹ç›²æ³¨...
    t.startHand()
}
```

### å…­ã€ ä¸‹ä¸€æ­¥

ç¾åœ¨ä½ çš„æµç¨‹æ˜¯ï¼š

1. Gateway æ¥æ”¶ WebSocketã€‚
    
2. ç©å®¶ç™¼é€Â `{"action": "sit_down", "seat": 2, "amount": 1000}`ã€‚
    
3. Table è™•ç†å…¥åº§ï¼Œç©å®¶ç‹€æ…‹ç‚ºÂ `SittingOut`ã€‚
    
4. Table æª¢æŸ¥äººæ•¸ > 2ï¼Œè§¸ç™¼Â `startHand()`ã€‚
    
5. æ‰€æœ‰åº§ä½ä¸Šçš„ç©å®¶ç‹€æ…‹è®Šç‚ºÂ `Playing`ã€‚
    

ç›®å‰ç³»çµ±å·²ç¶“å…·å‚™äº†ã€Œé–‹å±€ã€çš„æ¢ä»¶ã€‚

**æ¥ä¸‹ä¾†ä½ éœ€è¦è£œä¸Šã€Œç™¼ç‰Œèˆ‡ç›²æ³¨é‚è¼¯ (Dealing & Blinds)ã€ï¼š**

1. **æ´—ç‰Œï¼š**Â ç”¢ç”Ÿéš¨æ©Ÿç‰Œå †ã€‚
    
2. **ç™¼ç‰Œï¼š**Â æ´¾ç™¼å…©å¼µç§æœ‰ç‰Œçµ¦æ¯å€‹Â `StatusPlaying`Â çš„ç©å®¶ã€‚
    
3. **å¼·åˆ¶ä¸‹æ³¨ï¼š**Â è‡ªå‹•æ‰£é™¤å°ç›² (SB) å’Œå¤§ç›² (BB) çš„ç±Œç¢¼ã€‚
    

**ä½ è¦æˆ‘ç¹¼çºŒè©³ç´°è¦åŠƒã€Œæ´—ç‰Œèˆ‡ç™¼ç‰Œã€çš„å¯¦ä½œå—ï¼Ÿ**

ç¹¼çºŒè©³ç´°è¦åŠƒã€Œæ´—ç‰Œèˆ‡ç™¼ç‰Œã€çš„å¯¦ä½œ

é€™ä¸€æ­¥æ˜¯å¾·å·æ’²å…‹æœ€ç¥è–çš„æ™‚åˆ»ï¼šç™¼ç‰Œã€‚ åœ¨æŠ€è¡“ä¸Šï¼Œé€™åŒ…å«ä¸‰å€‹é—œéµç’°ç¯€ï¼š**éš¨æ©Ÿæ€§å®‰å…¨ (RNG Security)**ã€**ç›²æ³¨è¨ˆç®— (Blind Logic)**ã€ä»¥åŠ**ç‹€æ…‹åˆå§‹åŒ–**ã€‚

å°¤å…¶æ˜¯ã€Œç›²æ³¨è¨ˆç®—ã€ï¼Œåœ¨å…©äººå–®æŒ‘ (Heads-up) èˆ‡å¤šäººå±€çš„è¦å‰‡å®Œå…¨ä¸åŒï¼Œé€™æ˜¯æœ€å®¹æ˜“å¯«å‡º Bug çš„åœ°æ–¹ã€‚

ä»¥ä¸‹æ˜¯è©³ç´°å¯¦ä½œè¦åŠƒï¼š

---

### ä¸€ã€ å®‰å…¨æ´—ç‰Œ (Secure Shuffling)

çµ•å°ä¸è¦ä½¿ç”¨Â `math/rand`ï¼Œå› ç‚ºå®ƒæ˜¯å½éš¨æ©Ÿ (Pseudo-random)ï¼Œç¨®å­ (Seed) å¯è¢«é æ¸¬ã€‚è‹¥é§­å®¢çŒœåˆ°ç¨®å­ï¼Œå°±èƒ½é çŸ¥æ¥ä¸‹ä¾†çš„æ‰€æœ‰ç™¼ç‰Œã€‚

æˆ‘å€‘å¿…é ˆä½¿ç”¨Â `crypto/rand`Â é…åˆÂ **Fisher-Yates æ´—ç‰Œæ¼”ç®—æ³•**ã€‚

**`deck.go`**

Go

```
package poker

import (
	"crypto/rand"
	"math/big"
)

// å®šç¾©ä¸€å‰¯ç‰Œ (52å¼µ)
// æˆ‘å€‘ä½¿ç”¨ 0-51 çš„æ•´æ•¸è¡¨ç¤ºï¼Œä¹‹å¾Œå†é€éè½‰æ›å‡½æ•¸è®Šæˆäººçœ‹çš„å­—ä¸²
type Deck []int32

func NewDeck() Deck {
	d := make(Deck, 52)
	for i := 0; i < 52; i++ {
		d[i] = int32(i)
	}
	return d
}

// *** é—œéµï¼šåŠ å¯†ç´šæ´—ç‰Œ ***
func (d Deck) Shuffle() {
	n := len(d)
	for i := n - 1; i > 0; i-- {
		// ç”Ÿæˆ 0 åˆ° i ä¹‹é–“çš„å®‰å…¨éš¨æ©Ÿæ•¸
		jBig, _ := rand.Int(rand.Reader, big.NewInt(int64(i+1)))
		j := jBig.Int64()
		
		// äº¤æ›
		d[i], d[j] = d[j], d[i]
	}
}
```

---

### äºŒã€ å•Ÿå‹•æ–°ç‰Œå±€ (Start Hand Orchestrator)

é€™æ˜¯Â `Table`Â å…§éƒ¨çš„ä¸»æ§æµç¨‹ã€‚ç•¶Â `checkGameStart()`Â æ¢ä»¶æ»¿è¶³å¾Œï¼Œå°±æœƒå‘¼å«æ­¤å‡½å¼ã€‚

**`game_start.go`**Â (éš¸å±¬æ–¼ Table)

Go

```
func (t *Table) startHand() {
    fmt.Println("=== Starting New Hand ===")

    // 1. åˆå§‹åŒ–ç‹€æ…‹
    t.State = StatePreFlop
    t.Pot = 0
    t.CommunityCards = []string{} // æ¸…ç©ºå…¬ç‰Œ
    t.Deck = poker.NewDeck()      // æ‹¿ä¸€å‰¯æ–°ç‰Œ
    t.Deck.Shuffle()              // æ´—ç‰Œ

    // 2. ç§»å‹• Button (èŠå®¶ä½)
    t.moveButton()

    // 3. å¼·åˆ¶ä¸‹ç›²æ³¨ (Blinds & Antes)
    // é€™æ˜¯æœ€è¤‡é›œçš„ä¸€æ­¥ï¼Œæœƒå½±éŸ¿ CurrentPos (è¡Œå‹•é †ä½)
    nextActionPos := t.postBlinds()

    // 4. ç™¼æ‰‹ç‰Œ (Pre-Flop Deal)
    t.dealHoleCards()

    // 5. è¨­å®šç•¶å‰è¡Œå‹•è€…
    // ç›²æ³¨ä¸‹å®Œå¾Œï¼Œè¡Œå‹•æ¬Šäº¤çµ¦å¤§ç›²å·¦é‚Šçš„äºº (æ§å£ä½ UTG)
    t.CurrentPos = nextActionPos
    t.resetTimer() // é–‹å§‹å€’æ•¸

    // 6. å»£æ’­ã€ŒéŠæˆ²é–‹å§‹ã€
    t.broadcastState()
}
```

---

### ä¸‰ã€ ç›²æ³¨é‚è¼¯ (The Blinds Logic) - æ ¸å¿ƒé›£é»

é€™è£¡è¦ç‰¹åˆ¥è™•ç†Â **Heads-up (å…©äººå±€)**Â çš„ç‰¹æ®Šè¦å‰‡ï¼š

- **å¤šäººå±€ (3+):**Â Button -> å°ç›² (SB) -> å¤§ç›² (BB)ã€‚
    
- **å…©äººå±€ (2):**Â Button å°±æ˜¯å°ç›² (SB)ï¼Œå¦ä¸€äººæ˜¯å¤§ç›² (BB)ã€‚ä¸” Button å…ˆè¡Œå‹• (ç¿»ç‰Œå‰)ã€‚
    

**`table_blinds.go`**

Go

```
func (t *Table) postBlinds() int {
    // ç²å–ç•¶å‰ç›²æ³¨é‡‘é¡ (å¾ Tournament Config è®€å–)
    sbAmount := int64(50)  // ç¯„ä¾‹
    bbAmount := int64(100) // ç¯„ä¾‹

    n := len(t.activePlayers) // æœ¬å±€åƒèˆ‡äººæ•¸
    
    var sbPos, bbPos int

    // --- å®šä½ç›²æ³¨ä½ç½® ---
    if n == 2 {
        // ç‰¹æ®Šè¦å‰‡ï¼šHeads-up
        sbPos = t.DealerPos            // Button æ˜¯å°ç›²
        bbPos = t.nextActivePos(sbPos) // å°å®¶æ˜¯å¤§ç›²
    } else {
        // æ¨™æº–è¦å‰‡
        sbPos = t.nextActivePos(t.DealerPos) // Button ä¸‹ä¸€å®¶
        bbPos = t.nextActivePos(sbPos)       // SB ä¸‹ä¸€å®¶
    }

    // --- æ‰£é™¤ç±Œç¢¼ (ä¸¦è™•ç† All-in æƒ…æ³) ---
    t.forceBet(sbPos, sbAmount) // å°ç›²ä¸‹æ³¨
    t.forceBet(bbPos, bbAmount) // å¤§ç›²ä¸‹æ³¨
    
    t.MinBet = bbAmount // è¨­å®šæœ¬è¼ªæœ€å°åŠ æ³¨é¡ç‚ºå¤§ç›²

    // --- å›å‚³ä¸‹ä¸€å€‹è¡Œå‹•è€… (UTG) ---
    // ç¿»ç‰Œå‰ï¼Œè¡Œå‹•å¾å¤§ç›²çš„ä¸‹ä¸€å®¶é–‹å§‹
    utgPos := t.nextActivePos(bbPos)
    return utgPos
}

// å¼·åˆ¶ä¸‹æ³¨ (æ‰£æ¬¾ä¸¦åŠ åˆ°åº•æ± )
func (t *Table) forceBet(seatIdx int, amount int64) {
    player := t.Seats[seatIdx]
    if player == nil { return }

    actualBet := amount
    // å¦‚æœç±Œç¢¼ä¸è¶³ï¼Œå¼·åˆ¶ All-in
    if player.Chips < amount {
        actualBet = player.Chips
        player.IsAllIn = true
        // é€™è£¡æœªä¾†è¦æ¨™è¨˜ Side Pot
    }

    player.Chips -= actualBet
    player.CurrentBet = actualBet // è¨­å®šæœ¬è¼ªå·²ä¸‹æ³¨é¡
    t.Pot += actualBet
    
    fmt.Printf("Player %s posted blind: %d\n", player.ID, actualBet)
}

// è¼”åŠ©ï¼šå°‹æ‰¾ä¸‹ä¸€å€‹ã€Œåœ¨åº§ä¸”åƒèˆ‡éŠæˆ²ã€çš„åº§ä½ç´¢å¼•
func (t *Table) nextActivePos(currentIdx int) int {
    for i := 1; i <= 9; i++ {
        idx := (currentIdx + i) % 9 // ç’°ç‹€æœå°‹
        p := t.Seats[idx]
        // å¿…é ˆæœ‰äººï¼Œä¸”ç‹€æ…‹æ˜¯ Playing (æ’é™¤ SittingOut)
        if p != nil && p.Status == StatusPlaying {
            return idx
        }
    }
    return -1 // Should not happen
}
```

---

### å››ã€ ç™¼ç‰Œé‚è¼¯ (Dealing Logic)

é€™è£¡å°‡æ´—å¥½çš„Â `int32`Â ç‰Œç™¼çµ¦ç©å®¶ï¼Œä½†åœ¨å„²å­˜åˆ°Â `Player`Â ç‰©ä»¶æ™‚ï¼Œæˆ‘å€‘éœ€è¦åšè½‰æ›ï¼Œæˆ–è€…ä¿æŒÂ `int32`Â ç›´åˆ°å»£æ’­é‚£ä¸€åˆ»ã€‚ ç‚ºäº†æ–¹ä¾¿èª¿è©¦ï¼Œæˆ‘å€‘å‡è¨­Â `Player`Â çµæ§‹ç¾åœ¨å­˜çš„æ˜¯Â `string`Â (å¦‚ "Ah")ã€‚

**`table_deal.go`**

Go

```
func (t *Table) dealHoleCards() {
    // å¾·å·æ’²å…‹æ¯äººç™¼ 2 å¼µ
    // æ¨™æº–ç™¼ç‰Œé †åºï¼šå¾å°ç›²é–‹å§‹ç™¼ç¬¬ä¸€å¼µï¼Œç¹ä¸€åœˆï¼Œå†ç™¼ç¬¬äºŒå¼µ
    // é€™è£¡ç°¡åŒ–ï¼šç›´æ¥çµ¦æ¯äººç™¼ 2 å¼µ (é‚è¼¯ä¸Šç­‰åƒ¹ï¼Œé™¤éä½ åšå¯¦é«”ç™¼ç‰Œå‹•ç•«)
    
    cardIdx := 0
    for _, p := range t.activePlayers {
        // å¾ Deck å–å‡º 2 å¼µ
        c1 := t.Deck[cardIdx]
        c2 := t.Deck[cardIdx+1]
        cardIdx += 2

        // è½‰æ›ç‚ºå­—ä¸²ä¸¦å­˜å…¥ç©å®¶æ‰‹ç‰Œ
        // IntToCardString æ˜¯ä½ éœ€è¦å¯¦ä½œçš„å·¥å…·å‡½æ•¸ (0 -> "2c", 51 -> "As")
        p.HoleCards = []string{
            poker.IntToCardString(c1), 
            poker.IntToCardString(c2),
        }
        
        fmt.Printf("Dealt cards to %s (Hidden)\n", p.ID)
    }
    
    // åˆ‡é™¤å·²ç™¼å‡ºçš„ç‰Œ (Slice)
    t.Deck = t.Deck[cardIdx:]
}
```

---

### äº”ã€ æ•´åˆé©—è­‰ï¼šä¸€å€‹å®Œæ•´çš„é–‹å±€ Log

ç•¶ä½ çš„Â `startHand()`Â åŸ·è¡ŒæˆåŠŸæ™‚ï¼Œä½ çš„å¾Œç«¯ Log æ‡‰è©²æœƒé•·é€™æ¨£ï¼š

Plaintext

```
=== Starting New Hand ===
Table ID: 101, Active Players: 3
Button moved to Seat 0 (Player A)
Player B (Seat 1) posted SB: 50
Player C (Seat 2) posted BB: 100
Dealt cards to Player B
Dealt cards to Player C
Dealt cards to Player A
State changed to PREFLOP
Current Actor: Seat 0 (Player A) (UTG)
Broadcast sent to 3 clients.
```

### å…­ã€ ä¸‹ä¸€æ­¥

ç¾åœ¨ï¼Œç‰Œå±€å·²ç¶“é–‹å§‹äº†ï¼š

1. æœ‰äººä¸‹äº†ç›²æ³¨ã€‚
    
2. å¤§å®¶æ‰‹è£¡éƒ½æœ‰ç‰Œäº†ã€‚
    
3. ä¼ºæœå™¨æ­£åœ¨ç­‰å¾…Â `CurrentPos`Â (UTG) çš„ç©å®¶è¡Œå‹•ã€‚
    

æ¥ä¸‹ä¾†ä½ éœ€è¦è™•ç†Â **ã€Œç©å®¶çš„è¡Œå‹•é‚è¼¯ (Bet/Call/Fold)ã€**ã€‚ é€™æ¯”å…¥åº§å’Œç™¼ç‰Œæ›´è¤‡é›œï¼Œå› ç‚ºä½ éœ€è¦é©—è­‰ï¼š

- **Call:**Â é‡‘é¡å°ä¸å°ï¼Ÿï¼ˆè¦è£œå¤šå°‘ï¼Ÿï¼‰
    
- **Raise:**Â æœ€å°åŠ æ³¨é¡æ˜¯å¤šå°‘ï¼Ÿï¼ˆMini-Raise è¦å‰‡ï¼‰
    
- **All-in:**Â é‚Šæ± æ€éº¼ç®—ï¼Ÿ
    

**è«‹å•ä½ è¦æˆ‘å…ˆè©³ç´°è¦åŠƒã€Œåˆæ³•å‹•ä½œé©—è­‰ (Action Validation)ã€çš„é‚è¼¯ï¼Œé‚„æ˜¯ç›´æ¥é€²å…¥ã€ŒSide Pot (é‚Šæ± ) è¨ˆç®—ã€çš„æ·±æ°´å€ï¼Ÿ**

å…ˆè©³ç´°è¦åŠƒã€Œåˆæ³•å‹•ä½œé©—è­‰ (Action Validation)ã€çš„é‚è¼¯

é€™æ˜¯ä¸€å€‹éå¸¸åš´è¬¹çš„ç’°ç¯€ã€‚å‹•ä½œé©—è­‰ï¼ˆAction Validationï¼‰æ˜¯å¾Œç«¯é‚è¼¯çš„ã€Œé˜²ç«ç‰†ã€ã€‚å¦‚æœä¸åš´æ ¼æ ¡é©—ï¼Œå¯èƒ½æœƒç™¼ç”Ÿã€Œè² æ•¸ç±Œç¢¼ã€ã€ã€Œç„¡é™åŠ æ³¨ã€æˆ–è€…ã€Œæ˜æ˜æ²’éŒ¢å»è·Ÿæ³¨ã€çš„åš´é‡ Bugã€‚

æˆ‘å€‘å°‡é©—è­‰é‚è¼¯æ‹†åˆ†ç‚ºä¸‰å€‹å±¤æ¬¡ï¼š

1. **åŸºç¤è³‡æ ¼æ ¡é©— (Sanity Check):**Â æ˜¯ä¸æ˜¯ä½ çš„å›åˆï¼Ÿä½ é‚„åœ¨ä¸åœ¨ç©ï¼Ÿ
    
2. **é‚è¼¯è¦å‰‡æ ¡é©— (Logic Check):**Â é¢å°ä¸‹æ³¨èƒ½ä¸èƒ½éç‰Œ (Check)ï¼ŸåŠ æ³¨é‡‘é¡å¤ ä¸å¤  (Min-Raise)ï¼Ÿ
    
3. **è³‡é‡‘æ ¡é©— (Fund Check):**Â ä½ çš„éŒ¢å¤ ä¸å¤ åŸ·è¡Œé€™å€‹å‹•ä½œï¼Ÿï¼ˆè™•ç† All-in è½‰åŒ–ï¼‰ã€‚
    

---

### ä¸€ã€ æ ¸å¿ƒé©—è­‰å‡½æ•¸æ¶æ§‹

å»ºè­°åœ¨Â `Table`Â çµæ§‹ä¸­æ–°å¢ä¸€å€‹Â `validateAction`Â æ–¹æ³•ã€‚é€™å€‹æ–¹æ³•ä¸æ”¹è®Šç‹€æ…‹ï¼Œåªå›å‚³Â `error`Â æˆ–Â `ç¶“éä¿®æ­£çš„é‡‘é¡`ã€‚

**`table_action.go`**

Go

```
// è™•ç†ç©å®¶å‹•ä½œçš„ä¸»å…¥å£
func (t *Table) handleGameAction(act PlayerAction) {
    player := t.Players[act.PlayerID]
    
    // 1. åŸ·è¡Œé©—è­‰
    validatedAmount, err := t.validateAction(player, act)
    if err != nil {
        t.sendError(player.Conn, err.Error())
        return // é©—è­‰å¤±æ•—ï¼Œç›´æ¥å½ˆå›ï¼Œä¸å»£æ’­ï¼Œä¸æ›äºº
    }

    // 2. æ‡‰ç”¨å‹•ä½œ (æ‰£éŒ¢ã€æ›´æ–°ç‹€æ…‹)
    // æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨é©—è­‰éå¾Œçš„ validatedAmountï¼Œè€Œä¸æ˜¯å‰ç«¯å‚³ä¾†çš„ act.Amount
    t.applyAction(player, act.Type, validatedAmount)
    
    // 3. å»£æ’­ & æ¨é€²éŠæˆ²
    t.broadcastState()
    
    if t.isRoundComplete() {
        t.nextStreet()
    } else {
        t.moveToNextPlayer()
    }
}
```

---

### äºŒã€ è©³ç´°é©—è­‰é‚è¼¯ (The Validation Logic)

é€™è£¡æˆ‘å€‘å‡è¨­Â `act.Amount`Â ä»£è¡¨çš„æ˜¯Â **ã€Œæœ¬è¼ªç´¯è¨ˆæŠ•å…¥é‡‘é¡ (Raise To)ã€**ã€‚ ä¾‹å¦‚ï¼šå¦‚æœæˆ‘ä¹‹å‰ä¸‹æ³¨ 100ï¼Œç¾åœ¨åˆ¥äººåŠ æ³¨åˆ° 200ï¼Œæˆ‘æƒ³å†åŠ æ³¨åˆ° 500ã€‚å‰ç«¯å‚³ä¾†çš„Â `act.Amount`Â æ‡‰è©²æ˜¯ 500ï¼Œè€Œä¸æ˜¯å¢é‡ 400ã€‚é€™æ¨£è¨­è¨ˆå¾Œç«¯æœƒæ¯”è¼ƒå¥½å¯«ã€‚

Go

```
func (t *Table) validateAction(p *Player, act PlayerAction) (int64, error) {
    // --- Level 1: åŸºç¤è³‡æ ¼æ ¡é©— ---
    
    // 1. éŠæˆ²ç‹€æ…‹æª¢æŸ¥
    if t.State == StateIdle || t.State == StateShowdown {
        return 0, fmt.Errorf("game is not running")
    }

    // 2. ç©å®¶ç‹€æ…‹æª¢æŸ¥
    if p.Status != StatusPlaying || p.IsFolded || p.IsAllIn {
        return 0, fmt.Errorf("you cannot act right now")
    }

    // 3. è¡Œå‹•æ¬Šæª¢æŸ¥ (æ˜¯ä¸æ˜¯è¼ªåˆ°ä½ ï¼Ÿ)
    if t.Seats[t.CurrentPos].ID != p.ID {
        return 0, fmt.Errorf("not your turn")
    }

    // --- Level 2 & 3: å…·é«”å‹•ä½œæ ¡é©— ---
    
    // å–å¾—å ´ä¸Šç›®å‰æœ€é«˜ä¸‹æ³¨é¡ (Call çš„åŸºæº–)
    // æ³¨æ„ï¼št.MaxBet æ˜¯æœ¬è¼ªç›®å‰æœ€é«˜çš„ CurrentBet
    currentMaxBet := t.getMaxBet() 

    switch act.Type {
    
    case ActionFold:
        // æ£„ç‰Œæ°¸é åˆæ³•
        return 0, nil

    case ActionCheck:
        // åªæœ‰ç•¶ã€Œä½ è‡ªå·±å·²ç¶“ä¸‹æ³¨çš„é‡‘é¡ã€ç­‰æ–¼ã€Œå ´ä¸Šæœ€å¤§é‡‘é¡ã€æ™‚æ‰èƒ½ Check
        // ä¾‹å¦‚ï¼šå¤§ç›²åœ¨ç¿»ç‰Œå‰(ç„¡äººåŠ æ³¨)ï¼Œæˆ–æ˜¯ç¿»ç‰Œå¾Œå¤§å®¶éƒ½éç‰Œ
        if p.CurrentBet < currentMaxBet {
            return 0, fmt.Errorf("cannot check, you must call %d", currentMaxBet - p.CurrentBet)
        }
        return 0, nil

    case ActionCall:
        // è¨ˆç®—éœ€è¦è£œå¤šå°‘éŒ¢ (To Call)
        diff := currentMaxBet - p.CurrentBet
        
        // ç‰¹æ®Šæƒ…æ³ï¼šéŒ¢ä¸å¤ è·Ÿæ³¨ -> å¼·åˆ¶è½‰ç‚º All-in
        if p.Chips < diff {
            return p.Chips + p.CurrentBet, nil // å¯¦éš›æŠ•å…¥ = å‰©é¤˜ç±Œç¢¼ + å·²ä¸‹æ³¨
        }
        return currentMaxBet, nil // æ¨™æº– Callï¼ŒæŠ•å…¥é‡‘é¡ = å ´ä¸Šæœ€å¤§

    case ActionBet, ActionRaise:
        // é€™æ˜¯æœ€è¤‡é›œçš„éƒ¨åˆ†
        
        // 1. é‡‘é¡å¿…é ˆå¤§æ–¼å ´ä¸Šæœ€å¤§æ³¨ (å¦å‰‡å°±æ˜¯ Call)
        if act.Amount <= currentMaxBet {
            return 0, fmt.Errorf("raise amount must be greater than current bet %d", currentMaxBet)
        }

        // 2. è¨ˆç®—å¢é‡ (Raise By)
        raiseBy := act.Amount - currentMaxBet

        // 3. æœ€å°åŠ æ³¨é¡æª¢æŸ¥ (Min-Raise Rule)
        // è¦å‰‡ï¼šåŠ æ³¨å¢é‡å¿…é ˆ >= ä¸Šä¸€æ¬¡çš„åŠ æ³¨å¢é‡ (å¦‚æœæ˜¯ç¬¬ä¸€æ³¨ï¼Œå‰‡ >= å¤§ç›²)
        minRaiseDiff := t.MinRaiseDiff
        if minRaiseDiff == 0 {
             minRaiseDiff = t.BigBlind // é»˜èªç‚ºå¤§ç›²
        }

        // ç‰¹æ®Šè¦å‰‡ï¼šå¦‚æœä¸å¤ æœ€å°åŠ æ³¨é¡ï¼Œé™¤éä½ æ˜¯ All-in
        // ä¹Ÿå°±æ˜¯ï¼šä½ è¦åŠ æ³¨ï¼Œä½†ä½ å‰©ä¸‹çš„éŒ¢ä¸å¤ åŠ åˆ°æœ€å°é¡ï¼Œé‚£ä½ å¯ä»¥æŠŠå‰©ä¸‹çš„éŒ¢å…¨æ¨ (All-in Raise)
        totalNeeded := act.Amount - p.CurrentBet // éœ€è¦å¾ç±Œç¢¼å †æ‹¿å‡ºçš„éŒ¢
        if p.Chips < totalNeeded {
            // é€™æ˜¯ All-in Raiseï¼Œé›–ç„¶ä¸æ»¿è¶³ Min-Raiseï¼Œä½†åˆæ³•
            return p.CurrentBet + p.Chips, nil
        }

        // æ­£å¸¸åŠ æ³¨æª¢æŸ¥
        if raiseBy < minRaiseDiff {
            return 0, fmt.Errorf("raise amount too small, min raise to %d", currentMaxBet + minRaiseDiff)
        }

        // 4. è³‡é‡‘æª¢æŸ¥
        if p.Chips < totalNeeded {
            return 0, fmt.Errorf("not enough chips")
        }

        return act.Amount, nil

    default:
        return 0, fmt.Errorf("unknown action type")
    }
}
```

---

### ä¸‰ã€ ç‹€æ…‹æ›´æ–° (Apply Action)

é©—è­‰é€šéå¾Œï¼Œæˆ‘å€‘éœ€è¦å®‰å…¨åœ°æ›´æ–°Â `Table`Â å’ŒÂ `Player`Â çš„æ•¸æ“šã€‚

Go

```
func (t *Table) applyAction(p *Player, actionType ActionType, validatedAmount int64) {
    // è¨ˆç®—é€™æ¬¡å‹•ä½œå¯¦éš›ä¸Šè¦å¾ç©å®¶ç±Œç¢¼å †æ‰£å¤šå°‘éŒ¢
    // validatedAmount æ˜¯ã€Œæœ¬è¼ªç›®æ¨™æŠ•å…¥ç¸½é¡ã€
    // p.CurrentBet æ˜¯ã€Œæœ¬è¼ªå·²ç¶“æŠ•å…¥é‡‘é¡ã€
    cost := validatedAmount - p.CurrentBet
    
    // 1. æ‰£éŒ¢
    p.Chips -= cost
    p.CurrentBet = validatedAmount
    t.Pot += cost

    // 2. åˆ¤æ–·æ˜¯å¦ All-in
    if p.Chips == 0 && cost > 0 {
        p.IsAllIn = true
        actionType = ActionAllIn // å¼·åˆ¶æ¨™è¨˜ç‚º All-inï¼Œæ–¹ä¾¿å‰ç«¯é¡¯ç¤ºå‹•ç•«
    }

    // 3. æ›´æ–°æ¡Œå­å…¨åŸŸç‹€æ…‹ (å¦‚æœæ˜¯åŠ æ³¨)
    if validatedAmount > t.MaxBet {
        // è¨ˆç®—é€™ä¸€æ‰‹çš„åŠ æ³¨å¢é‡ (ç”¨æ–¼è¨ˆç®—ä¸‹ä¸€æ¬¡ Min-Raise)
        raiseDiff := validatedAmount - t.MaxBet
        if raiseDiff > t.MinRaiseDiff {
            t.MinRaiseDiff = raiseDiff // æ›´æ–°æœ€å°åŠ æ³¨æ¨™ç«¿
        }
        
        t.MaxBet = validatedAmount // æ›´æ–°å ´ä¸Šæœ€å¤§æ³¨
        
        // *** é—œéµï¼šé‡å•Ÿã€Œå›åˆçµæŸã€çš„åˆ¤å®š ***
        // å› ç‚ºæœ‰äººåŠ æ³¨äº†ï¼Œå…¶ä»–æ‰€æœ‰åŸæœ¬å·²ç¶“ Call çš„äººï¼Œéƒ½éœ€è¦é‡æ–°è¡¨æ…‹
        // æ‰€ä»¥æˆ‘å€‘è¦é‡ç½®æŸäº›æ¨™è¨˜ (å…·é«”åœ¨ moveToNextPlayer è™•ç†)
        t.LastAggressor = p.SeatIdx
    }

    // 4. è¨­å®šå‹•ä½œæ¨™è¨˜ (ç”¨æ–¼å‰ç«¯é¡¯ç¤º "Check", "Call", "Raise")
    // æˆ‘å€‘å¯ä»¥å°‡é€™å€‹å‹•ä½œè¨˜éŒ„åˆ° HandHistory
    fmt.Printf("Player %s did %v, chips left: %d\n", p.ID, actionType, p.Chips)
    
    // ç‰¹æ®Šè™•ç† Fold
    if actionType == ActionFold {
        p.IsFolded = true
    }
}
```

---

### å››ã€ å¹¾å€‹å¿…é ˆæ³¨æ„çš„ã€Œå¾·æ’²é™·é˜±ã€

1. **Min-Raise çš„é‡æ–°é–‹å•Ÿ (Re-opening the betting):**
    
    - å¦‚æœ A ä¸‹æ³¨ 100ï¼ŒB All-in 120 (åŠ æ³¨ 20)ã€‚
        
    - é€™æ™‚å¢é‡åªæœ‰ 20ï¼Œ**å°æ–¼**Â æœ€å°åŠ æ³¨é¡ (å‡è¨­å¤§ç›² 100)ã€‚
        
    - é€™å±¬æ–¼ "Incomplete Raise"ã€‚
        
    - è¦å‰‡ï¼šå¦‚æœåŠ æ³¨é¡æœªé”åˆ°æ¨™æº–çš„ä¸€åŠï¼ˆæˆ–æ¨™æº–ï¼Œè¦–è³­å ´è¦å‰‡ï¼‰ï¼Œå‰‡**ä¸é‡é–‹**ä¸‹æ³¨æ¬Šã€‚æ„æ€æ˜¯ï¼Œå¦‚æœè¼ªå› Aï¼ŒAÂ **ä¸èƒ½å†åŠ æ³¨**ï¼Œåªèƒ½ Call 120ã€‚
        
    - _å¯¦ä½œå»ºè­°ï¼š_Â é€™æ¯”è¼ƒé€²éšï¼ŒåˆæœŸå¯ä»¥å…ˆå¿½ç•¥ï¼Œçµ±ä¸€å…è¨±å†åŠ æ³¨ï¼Œæˆ–è€…åš´æ ¼åŸ·è¡Œ Min-Raiseã€‚
        
2. **å¤šäººåº•æ± çš„ Side Pot æ¨™è¨˜:**
    
    - åœ¨Â `applyAction`Â ä¸­ï¼Œå¦‚æœç™¼ç”Ÿäº†Â `IsAllIn`ï¼Œä½ æ‡‰è©²åœ¨æ­¤æ™‚è¨˜éŒ„ä¸€å€‹ "Pending Side Pot Check"ã€‚
        
    - å› ç‚ºåœ¨é€™ä¸€è¼ªçµæŸå‰ï¼Œå¯èƒ½æœƒæœ‰ 3 å€‹äºº All-inï¼Œç”¢ç”Ÿå¤šå€‹ Side Potã€‚æˆ‘å€‘é€šå¸¸åœ¨Â **ã€Œæœ¬è¼ªçµæŸ (Round Complete)ã€**Â è½‰ç§»åˆ°ä¸‹ä¸€æ¢è¡— (Next Street) çš„ç¬é–“ï¼Œçµ±ä¸€è¨ˆç®—å’Œåˆ‡åˆ† Side Potã€‚
        

---

### äº”ã€ ä¸‹ä¸€æ­¥

ç¾åœ¨ä½ çš„ä¼ºæœå™¨å·²ç¶“å¯ä»¥ï¼š

1. æ¥æ”¶ç©å®¶å‹•ä½œã€‚
    
2. åš´æ ¼é©—è­‰å‹•ä½œåˆæ³•æ€§ï¼ˆæ“‹ä½ä½œå¼Šï¼‰ã€‚
    
3. æ­£ç¢ºæ‰£æ¬¾ä¸¦æ›´æ–°åº•æ± ã€‚
    

æ¥ä¸‹ä¾†çš„æµç¨‹æ˜¯ï¼šÂ `Validate`Â ->Â `Apply`Â ->Â **`Check Round Complete?`**

å¦‚æœé€™è¼ªé‚„æ²’çµæŸï¼ˆé‚„æœ‰äººæ²’è¡¨æ…‹ï¼‰ï¼Œå°±Â `moveToNextPlayer`ã€‚ å¦‚æœé€™è¼ªçµæŸäº†ï¼ˆå¤§å®¶éƒ½ Call å¹³äº†ï¼‰ï¼Œå°±Â `nextStreet`ï¼ˆç™¼ç¿»ç‰Œï¼‰ã€‚

**æˆ‘å»ºè­°ä¸‹ä¸€æ­¥é€²è¡Œã€Œå›åˆçµæŸåˆ¤å®š (Round Completion)ã€èˆ‡ã€Œé‚Šæ± åˆ‡åˆ† (Side Pot Calculation)ã€çš„å¯¦ä½œã€‚**Â é€™å…©è€…æ˜¯ç¶åœ¨ä¸€èµ·çš„ï¼Œå› ç‚ºé‚Šæ± åˆ‡åˆ†åªç™¼ç”Ÿåœ¨å›åˆçµæŸã€æº–å‚™ç™¼ä¸‹ä¸€å¼µå…¬ç‰Œçš„æ™‚å€™ã€‚

**ä½ æƒ³å…ˆçœ‹ã€Œå›åˆçµæŸçš„åˆ¤æ–·é‚è¼¯ã€å—ï¼Ÿ**

å…ˆçœ‹ã€Œå›åˆçµæŸçš„åˆ¤æ–·é‚è¼¯ã€

é€™æ˜¯ä¸€å€‹çœ‹ä¼¼ç°¡å–®ï¼Œä½†éš±è—è‘—å¾ˆå¤šé‚Šç·£æƒ…æ³ï¼ˆEdge Casesï¼‰çš„é‚è¼¯ã€‚

åœ¨å¾·å·æ’²å…‹ä¸­ï¼Œã€Œå›åˆçµæŸã€å¿…é ˆ**åŒæ™‚æ»¿è¶³**å…©å€‹æ¢ä»¶ï¼š

1. **è³‡é‡‘å¹³è¡¡ (Pot Balanced):**Â æ‰€æœ‰**æœªè“‹ç‰Œä¸”æœª All-in**Â çš„ç©å®¶ï¼Œæœ¬è¼ªä¸‹æ³¨é‡‘é¡å¿…é ˆç­‰æ–¼å ´ä¸Šçš„Â `MaxBet`ã€‚
    
2. **è¡¨æ…‹å®Œç•¢ (Action Taken):**Â æ‰€æœ‰**æœªè“‹ç‰Œä¸”æœª All-in**Â çš„ç©å®¶ï¼Œéƒ½å·²ç¶“åŸ·è¡Œéè‡³å°‘ä¸€æ¬¡å‹•ä½œï¼ˆCheck/Call/Bet/Raiseï¼‰ã€‚
    

**ç‚ºä»€éº¼éœ€è¦ç¬¬äºŒé»ï¼Ÿ**Â æƒ³åƒç¿»ç‰Œå¾Œ (Flop)ï¼Œå¤§å®¶éƒ½éç‰Œ (Check)ã€‚æ­¤æ™‚Â `MaxBet`Â æ˜¯ 0ï¼Œæ‰€æœ‰äººçš„Â `CurrentBet`Â ä¹Ÿæ˜¯ 0ï¼ˆè³‡é‡‘å¹³è¡¡ï¼‰ã€‚å¦‚æœæ²’æœ‰æª¢æŸ¥ã€Œæ˜¯å¦è¡¨æ…‹ã€ï¼Œç¨‹å¼æœƒä»¥ç‚ºå›åˆçµæŸäº†ï¼Œå°è‡´é€£ Check çš„æ©Ÿæœƒéƒ½æ²’æœ‰å°±ç›´æ¥è·³è½‰ç‰Œã€‚

---

### ä¸€ã€ è³‡æ–™çµæ§‹æ“´å……

æˆ‘å€‘éœ€è¦åœ¨Â `Player`Â çµæ§‹ä¸­å¢åŠ ä¸€å€‹æ¨™è¨˜ï¼Œè¨˜éŒ„ã€Œä»–åœ¨é€™ä¸€è¼ªæ˜¯å¦å·²ç¶“è¡Œå‹•éã€ã€‚

**`models.go`**

Go

```
type Player struct {
    // ... åŸæœ‰æ¬„ä½
    
    HasActed bool // *** æ–°å¢ï¼šæœ¬è¼ªæ˜¯å¦å·²è¡¨æ…‹ ***
}
```

é€™å€‹Â `HasActed`Â æ¨™è¨˜éå¸¸é‡è¦ï¼š

- **æ¯è¼ªé–‹å§‹æ™‚ (NextStreet):**Â å…¨éƒ¨é‡ç½®ç‚ºÂ `false`ã€‚
    
- **ç©å®¶è¡Œå‹•å¾Œ (ApplyAction):**Â è¨­å®šç‚ºÂ `true`ã€‚
    

---

### äºŒã€ æ ¸å¿ƒåˆ¤æ–·é‚è¼¯ (The Logic)

é€™å€‹å‡½æ•¸Â `isRoundComplete`Â æœƒéæ­·æ‰€æœ‰åº§ä½ä¸Šçš„ç©å®¶ã€‚åªè¦ç™¼ç¾**ä»»ä½•ä¸€å€‹**ä¸æ»¿è¶³æ¢ä»¶çš„äººï¼Œå°±å›å‚³Â `false`ã€‚

**`table_flow.go`**

Go

```
// åˆ¤æ–·æœ¬è¼ªä¸‹æ³¨æ˜¯å¦çµæŸ
func (t *Table) isRoundComplete() bool {
    activeCount := 0   // é‚„æœ‰ç±Œç¢¼ä¸”æ²’è“‹ç‰Œçš„äººæ•¸
    allInCount := 0    // All-in çš„äººæ•¸
    
    for _, p := range t.Seats {
        if p == nil { continue }
        
        // 1. å·²è“‹ç‰Œçš„ç©å®¶ï¼Œç›´æ¥å¿½ç•¥
        if p.IsFolded { continue }

        // 2. All-in çš„ç©å®¶
        if p.IsAllIn {
            allInCount++
            // All-in ç©å®¶ä¸éœ€è¦å†è£œéŒ¢ï¼Œä¹Ÿä¸éœ€è¦å†è¡¨æ…‹ï¼Œç›´æ¥ç®—é€šé
            continue 
        }

        // --- é‡å°ã€Œæ´»èºç©å®¶ã€çš„æª¢æŸ¥ ---
        activeCount++

        // æ¢ä»¶ A: è³‡é‡‘æ˜¯å¦å¹³è¡¡ï¼Ÿ
        // å¦‚æœä½ ä¸‹çš„æ³¨å°‘æ–¼å ´ä¸Šæœ€å¤§æ³¨ï¼Œä»£è¡¨ä½ é‚„æ²’ Callï¼Œå›åˆä¸èƒ½çµæŸ
        if p.CurrentBet != t.MaxBet {
            return false
        }

        // æ¢ä»¶ B: æ˜¯å¦å·²è¡¨æ…‹ï¼Ÿ
        // ä¸»è¦æ˜¯ç‚ºäº†é˜²æ­¢ï¼šå¤§å®¶éƒ½æ˜¯ 0 ä¸‹æ³¨ï¼Œä½†é‚„æ²’è¼ªåˆ°å¾Œé¢çš„äºº Check
        if !p.HasActed {
            return false
        }
    }

    // --- ç‰¹æ®Šæƒ…æ³æª¢æŸ¥ ---

    // æƒ…æ³ 1: å…¨å ´åªå‰© 1 å€‹äººæ²’è“‹ç‰Œ (å…¶ä»–äººFoldäº†)
    // å…¶å¯¦é€™æ‡‰è©²åœ¨ handleAction è£¡å°±å…ˆæª¢æŸ¥ "CheckWinnerByFold"ï¼Œä½†é€™è£¡é˜²å‘†
    if activeCount + allInCount == 1 {
        return true 
    }

    // æƒ…æ³ 2: å¤§å®¶éƒ½ All-in äº†ï¼Œæˆ–è€…åªå‰© 1 å€‹æ´»äººå…¶ä»–éƒ½ All-in
    // é€™ç¨®æƒ…æ³ä¸‹ï¼Œè³‡é‡‘å¯èƒ½ä¸å¹³è¡¡ (Side Pot)ï¼Œä½†ç„¡äººèƒ½å†å‹•ä½œï¼Œæ‰€ä»¥å›åˆå¿…é ˆçµæŸ
    if activeCount == 0 {
        return true
    }

    // æ­£å¸¸çµæŸ
    return true
}
```

---

### ä¸‰ã€ æ•´åˆé€² Action æµç¨‹

æˆ‘å€‘éœ€è¦ä¿®æ”¹ä¹‹å‰çš„Â `applyAction`Â å’ŒÂ `nextStreet`Â ä¾†é…åˆé€™å€‹é‚è¼¯ã€‚

#### 1. ä¿®æ”¹Â `applyAction`Â (æ›´æ–° HasActed)

Go

```
func (t *Table) applyAction(p *Player, actionType ActionType, amount int64) {
    // ... (ä¹‹å‰çš„æ‰£æ¬¾èˆ‡ Pot é‚è¼¯) ...

    // *** æ–°å¢ï¼šæ¨™è¨˜å·²è¡¨æ…‹ ***
    p.HasActed = true
    
    // å¦‚æœæ˜¯ Raise (åŠ æ³¨)ï¼Œä»£è¡¨é€™ä¸€è¼ªçš„åŸºæº–ç·šè®Šäº†
    // æ‰€æœ‰å…¶ä»–äººçš„ã€Œå·²åŒæ„ã€ç‹€æ…‹å°±å¤±æ•ˆäº†ï¼ˆé›–ç„¶ HasActed é‚„æ˜¯ trueï¼Œä½† money check æœƒå¤±æ•—ï¼‰
    // é€™ä¸éœ€è¦é¡å¤–é‡ç½® HasActedï¼Œå› ç‚º isRoundComplete æœƒå…ˆæª¢æŸ¥ CurrentBet != MaxBet
}
```

#### 2. ä¿®æ”¹Â `nextStreet`Â (é‡ç½® HasActed)

Go

```
func (t *Table) nextStreet() {
    // 1. é‚Šæ± è¨ˆç®— (æˆ‘å€‘ä¸‹ä¸€æ­¥è¦åšçš„äº‹)
    t.calculateSidePots()

    // 2. ç‹€æ…‹æµè½‰
    switch t.State {
    case StatePreFlop:
        t.State = StateFlop
        t.dealCommunityCards(3)
    case StateFlop:
        t.State = StateTurn
        t.dealCommunityCards(1)
    // ...
    }

    // 3. *** é—œéµï¼šç‚ºæ–°çš„ä¸€è¼ªé‡ç½®æ•¸æ“š ***
    t.MaxBet = 0
    t.MinRaiseDiff = t.BigBlind // é‡ç½®æœ€å°åŠ æ³¨é¡
    t.LastAggressor = -1        // é‡ç½®æ”»æ“Šè€…

    for _, p := range t.Seats {
        if p == nil { continue }
        p.CurrentBet = 0
        p.HasActed = false // *** é‡ç½®è¡¨æ…‹æ¨™è¨˜ ***
    }

    // 4. å¦‚æœå…¨å ´åªå‰© 1 å€‹æˆ– 0 å€‹ã€Œé All-inã€ç©å®¶
    // (ä¾‹å¦‚ï¼š3äººå±€ï¼Œ2äººå·² All-inï¼Œå‰© 1 äººæŒæœ‰ç±Œç¢¼)
    // é€™æ™‚å€™å¾Œé¢çš„å¹¾æ¢è¡—éƒ½ä¸ç”¨æ‰“ï¼Œç›´æ¥ç™¼ç‰Œåˆ°åº• (Run it out)
    if t.countActivePlayers() < 2 {
        // éè¿´å‘¼å«è‡ªå·±ï¼Œç›´åˆ° Showdownï¼Œæˆ–è€…è¨­å®šä¸€å€‹å»¶é² timer è‡ªå‹•è·‘å®Œ
        time.AfterFunc(time.Second * 1, t.nextStreet)
        return
    }

    // 5. å°‹æ‰¾èµ·å§‹è¡Œå‹•è€… (SB/BB é‚è¼¯)
    // ç¿»ç‰Œå¾Œï¼Œæ°¸é æ˜¯å¾ Button çš„ä¸‹ä¸€å®¶é–‹å§‹
    t.CurrentPos = t.nextActivePos(t.DealerPos)
    t.broadcastState()
}
```

---

### å››ã€ ä¸€å€‹å¸¸è¦‹çš„ Bugï¼šå¤§ç›²çš„ã€Œéç‰Œæ¬Šã€

åœ¨Â **PreFlop (ç¿»ç‰Œå‰)**ï¼Œå¤§ç›² (BB) å·²ç¶“ä¸‹æ³¨äº† 100ã€‚ å‡è¨­å‰é¢çš„äººéƒ½ Call 100ã€‚ è¼ªåˆ°å¤§ç›²æ™‚ï¼š

- `p.CurrentBet`Â (100) ==Â `t.MaxBet`Â (100)ã€‚
    
- å¦‚æœæ˜¯èˆŠé‚è¼¯ï¼Œç¨‹å¼å¯èƒ½æœƒåˆ¤å®šå›åˆçµæŸï¼Œç›´æ¥ç™¼ç¿»ç‰Œã€‚
    
- **ä½†é€™æ˜¯éŒ¯çš„ï¼**Â å¤§ç›²æœ‰æ¬Šåˆ©åŠ æ³¨ (Option)ã€‚
    

**ä½¿ç”¨æˆ‘å€‘ä¸Šé¢çš„Â `HasActed`Â é‚è¼¯ï¼Œé€™å€‹ Bug æœƒè¢«å®Œç¾è§£æ±ºï¼š**

1. ç™¼ç‰Œå‰ï¼Œå¤§ç›²è¢«è¿«ä¸‹ç›²æ³¨ã€‚æ­¤æ™‚æˆ‘å€‘**ä¸è¦**è¨­Â `HasActed = true`Â (æˆ–è€…åœ¨ç™¼ç‰Œå¾Œçµ±ä¸€é‡ç½®ç‚º false)ã€‚
    
2. è¼ªåˆ°å¤§ç›²æ™‚ï¼Œé›–ç„¶éŒ¢å¤ äº†ï¼Œä½†Â `HasActed`Â æ˜¯ falseã€‚
    
3. `isRoundComplete`Â å›å‚³Â `false`ã€‚
    
4. å¤§ç›²åŸ·è¡Œ Checkã€‚
    
5. `applyAction`Â è¨­å®šÂ `HasActed = true`ã€‚
    
6. `isRoundComplete`Â å›å‚³Â `true`Â -> é€² Flopã€‚
    

---

### äº”ã€ ä¸‹ä¸€æ­¥

ç¾åœ¨ä½ çš„ä¼ºæœå™¨å·²ç¶“èƒ½æ­£ç¢ºåˆ¤æ–·ã€Œä½•æ™‚è©²ç™¼ä¸‹ä¸€å¼µç‰Œã€äº†ã€‚

ä½†é€™è£¡è—è‘—ä¸€å€‹å·¨å¤§çš„å‘ï¼š**ç•¶å›åˆçµæŸæ™‚ï¼Œå¦‚æœæœ‰å¤šå€‹ç©å®¶ All-inï¼Œç±Œç¢¼æ˜¯ä¸å‡ç­‰çš„ã€‚**Â é€™æ™‚å€™ä½ ä¸èƒ½ç°¡å–®åœ°æŠŠæ‰€æœ‰éŒ¢éƒ½å †åœ¨ä¸€å€‹Â `Pot`Â è£¡ï¼Œå¦å‰‡ç±Œç¢¼å¤šçš„äººè´äº†ç±Œç¢¼å°‘çš„äººï¼ŒæœƒæŠŠå¤šå‡ºçš„éƒ¨åˆ†ä¹Ÿè´èµ°ï¼ˆé€™æ˜¯ä¸å…¬å¹³çš„ï¼‰ã€‚

ä½ éœ€è¦é€²è¡ŒÂ **ã€Œåˆ‡åˆ†é‚Šæ±  (Side Pot Calculation)ã€**ã€‚

**é€™æ˜¯å¾·å·æ’²å…‹å¾Œç«¯æœ€é›£çš„æ•¸å­¸é‚è¼¯ï¼Œæº–å‚™å¥½è¦è©³ç´°è¦åŠƒé€™ä¸€å¡Šäº†å—ï¼Ÿ**

è©³ç´°è¦åŠƒé€™ä¸€å¡Š

é€™ç¢ºå¯¦æ˜¯å¾·å·æ’²å…‹å¾Œç«¯é–‹ç™¼ä¸­çš„ã€Œå¤§é­”ç‹ã€ã€‚å¦‚æœé‚Šæ± ç®—éŒ¯ï¼Œç©å®¶è´äº†éŒ¢å»æ‹¿ä¸åˆ°ï¼Œæˆ–è€…è¼¸äº†éŒ¢å»æ‹¿å›ä¸€éƒ¨åˆ†ï¼Œé€™æ˜¯çµ•å°ç„¡æ³•æ¥å—çš„åš´é‡ Bugã€‚

è¦ç†è§£é‚Šæ± ï¼ˆSide Potï¼‰ï¼Œæœ€å¥½ä½¿ç”¨Â **ã€Œæ©«åˆ‡ (Horizontal Slicing)ã€**Â çš„æ¦‚å¿µï¼Œè€Œä¸æ˜¯æŠŠç±Œç¢¼æƒ³æˆä¸€å †ã€‚

æƒ³åƒæ‰€æœ‰ç©å®¶çš„ç±Œç¢¼åƒæŸ±å­ä¸€æ¨£ç–Šåœ¨æ¡Œä¸Šã€‚ç•¶æœ‰äºº All-in ä¸”ç±Œç¢¼è¼ƒå°‘æ™‚ï¼Œæˆ‘å€‘æ‹¿ä¸€æŠŠåˆ€ï¼Œä¾ç…§é‚£å€‹äººçš„ç±Œç¢¼é«˜åº¦ï¼Œæ©«å‘åˆ‡ä¸€åˆ€ã€‚

- **åˆ€å­ä¸‹æ–¹çš„ç±Œç¢¼**ï¼šé€²å…¥Â **ä¸»æ±  (Main Pot)**ï¼Œæ‰€æœ‰äººéƒ½æœ‰è³‡æ ¼æ¶ã€‚
    
- **åˆ€å­ä¸Šæ–¹çš„ç±Œç¢¼**ï¼šé€²å…¥Â **é‚Šæ±  (Side Pot)**ï¼Œåªæœ‰ç±Œç¢¼å¤ é«˜çš„äººæ‰æœ‰è³‡æ ¼æ¶ã€‚
    

---

### ä¸€ã€ æ•¸æ“šçµæ§‹å‡ç´š

æˆ‘å€‘å¿…é ˆæ”¾æ£„å–®ç´”çš„Â `t.Pot = 100`Â é€™ç¨®å¯«æ³•ã€‚åº•æ± å¿…é ˆè®Šæˆä¸€å€‹Â **ç‰©ä»¶åˆ‡ç‰‡ (Slice of Objects)**ã€‚

**`models.go`Â (Pot çµæ§‹)**

Go

```
type Pot struct {
    Amount    int64           // é€™å€‹æ± è£¡æœ‰å¤šå°‘éŒ¢
    Eligibles map[string]bool // èª°æœ‰è³‡æ ¼è´é€™å€‹æ±  (ç™½åå–®)
    IsClosed  bool            // æ˜¯å¦å·²å°å­˜ (ä¸èƒ½å†å¾€è£¡åŠ éŒ¢)
}

// Table çµæ§‹æ›´æ–°
type Table struct {
    // ...
    // åŸæœ¬æ˜¯ Pot int64ï¼Œç¾åœ¨æ”¹ç‚ºï¼š
    Pots []*Pot 
}
```

åˆå§‹åŒ–æ™‚ï¼Œæ¡Œå­ä¸Šè‡³å°‘æœƒæœ‰ä¸€å€‹ç©ºçš„ Main Pot (`Pots[0]`)ã€‚

---

### äºŒã€ æ ¸å¿ƒæ¼”ç®—æ³•ï¼šè¿­ä»£æ¸›æ³• (Iterative Subtraction)

é€™å€‹æ¼”ç®—æ³•åœ¨Â `nextStreet()`Â çš„æœ€é–‹å§‹åŸ·è¡Œã€‚å®ƒçš„ç›®æ¨™æ˜¯æŠŠå¤§å®¶æ”¾åœ¨æ¡Œä¸Šçš„Â `CurrentBet`Â æ¸…é›¶ï¼Œä¸¦æ­£ç¢ºåˆ†é…åˆ°Â `Pots`Â é™£åˆ—ä¸­ã€‚

**é‚è¼¯æ­¥é©Ÿï¼š**

1. æ‰¾å‡ºæœ¬è¼ªæ‰€æœ‰Â **All-in ç©å®¶**Â çš„Â `CurrentBet`ã€‚
    
2. å°‡é€™äº›é‡‘é¡æ’åºï¼ˆå¾å°åˆ°å¤§ï¼‰ï¼Œå»é™¤é‡è¤‡ï¼Œé€™äº›å°±æ˜¯Â **ã€Œåˆ‡å‰²ç·š (Cut Levels)ã€**ã€‚
    
3. éæ­·æ¯ä¸€æ¢åˆ‡å‰²ç·šÂ `Level`ï¼š
    
    - è¨ˆç®—Â `contribution = Level - prevLevel`ã€‚
        
    - å¾æ¯å€‹ç©å®¶çš„Â `CurrentBet`Â ä¸­æ‰£é™¤Â `contribution`ï¼ˆå¦‚æœä¸å¤ æ‰£å°±æ‰£å…‰ï¼‰ã€‚
        
    - å°‡æ‰£é™¤çš„ç¸½é¡åŠ å…¥ç•¶å‰æœ€æ–°çš„ Potã€‚
        
    - å¦‚æœæœ‰ç©å®¶åœ¨é€™å€‹ Level å‰›å¥½æ‰£å…‰äº†ç±Œç¢¼ï¼ˆä»£è¡¨ä»–æ˜¯é€™å€‹ All-in Level çš„è§¸ç™¼è€…ï¼‰ï¼Œå‰‡å°‡ç•¶å‰ PotÂ **å°å­˜ (Close)**ï¼Œé™åˆ¶åªæœ‰ã€Œæœ‰è²¢ç»çš„äººã€èƒ½è´ã€‚
        
    - å‰µå»ºä¸€å€‹æ–°çš„ Side Pot ä¾›å‰©ä¸‹çš„ç±Œç¢¼ä½¿ç”¨ã€‚
        
4. æœ€å¾Œï¼Œå¦‚æœå¤§å®¶é‚„æœ‰å‰©é¤˜çš„Â `CurrentBet`ï¼ˆé All-in çš„æ™®é€šä¸‹æ³¨ï¼‰ï¼Œå…¨éƒ¨ä¸Ÿé€²æœ€å¾Œä¸€å€‹ Potã€‚
    

---

### ä¸‰ã€ ç¨‹å¼ç¢¼å¯¦ä½œ

é€™æ˜¯æ•´å€‹ Server æœ€æ ¸å¿ƒçš„è³‡ç”¢è™•ç†å‡½æ•¸ã€‚

**`table_pot.go`**

Go

```
func (t *Table) calculateSidePots() {
    // 1. æ‰¾å‡ºæ‰€æœ‰ä¸åŒçš„ All-in é‡‘é¡ (ä½œç‚ºåˆ‡å‰²é»)
    allInAmounts := make(map[int64]bool)
    for _, p := range t.Seats {
        if p != nil && p.IsAllIn && p.CurrentBet > 0 {
            allInAmounts[p.CurrentBet] = true
        }
    }
    
    // æ’åºåˆ‡å‰²é» (ä¾‹å¦‚: 100, 300, 500)
    var levels []int64
    for amt := range allInAmounts {
        levels = append(levels, amt)
    }
    sort.Slice(levels, func(i, j int) bool { return levels[i] < levels[j] })

    // 2. é€å±¤åˆ‡å‰²
    var prevLevel int64 = 0
    
    for _, level := range levels {
        contribution := level - prevLevel
        if contribution <= 0 { continue }
        
        t.addToPot(contribution) // *** æ ¸å¿ƒæ“ä½œ ***
        
        // åˆ‡å®Œé€™ä¸€å±¤å¾Œï¼Œå¿…é ˆå°å­˜ç•¶å‰ Potï¼Œä¸¦é–‹ä¸€å€‹æ–°çš„
        // å› ç‚ºé€™ä¸€å±¤æ˜¯æŸå€‹ All-in ç©å®¶çš„æ¥µé™
        t.closeCurrentPot()
        
        prevLevel = level
    }

    // 3. è™•ç†å‰©ä¸‹çš„ç±Œç¢¼ (é All-in ç©å®¶çš„å¤šé¤˜éƒ¨åˆ†)
    // é€™è£¡å‚³å…¥ä¸€å€‹å¾ˆå¤§çš„æ•¸ï¼Œä»£è¡¨ã€ŒæŠŠå‰©ä¸‹çš„å…¨æ”¶äº†ã€
    t.addToPot(1<<62) 
    
    // 4. é‡ç½®æ‰€æœ‰äººçš„æœ¬è¼ªä¸‹æ³¨
    for _, p := range t.Seats {
        if p != nil {
            p.CurrentBet = 0
        }
    }
}

// è¼”åŠ©ï¼šå°‡æŒ‡å®šé‡‘é¡å¾ç©å®¶ CurrentBet ç§»å…¥ç•¶å‰ Pot
func (t *Table) addToPot(amountLimit int64) {
    currentPot := t.Pots[len(t.Pots)-1] // å–å‡ºæœ€æ–°çš„ Pot
    
    // ç¢ºä¿ Eligibles å·²åˆå§‹åŒ–
    if currentPot.Eligibles == nil {
        currentPot.Eligibles = make(map[string]bool)
        // é è¨­æ‰€æœ‰ã€Œé‚„æ²’è“‹ç‰Œã€çš„äººéƒ½æœ‰è³‡æ ¼ (ç¨å¾Œæœƒå‰”é™¤)
        for _, p := range t.Seats {
            if p != nil && !p.IsFolded {
                currentPot.Eligibles[p.ID] = true
            }
        }
    }

    var potTotal int64 = 0

    for _, p := range t.Seats {
        if p == nil { continue }
        
        // æ¯å€‹ç©å®¶èƒ½è²¢ç»çš„é¡åº¦ = min(ä»–æ¡Œä¸Šçš„éŒ¢, é€™æ¬¡çš„åˆ‡å‰²é¡åº¦)
        amount := amountLimit
        if p.CurrentBet < amount {
            amount = p.CurrentBet
        }
        
        if amount > 0 {
            p.CurrentBet -= amount
            potTotal += amount
            
            // å¦‚æœé€™å€‹äººå·²ç¶“è“‹ç‰Œäº†ï¼ŒéŒ¢ç…§æ”¶ï¼Œä½†å¾ç™½åå–®ç§»é™¤
            if p.IsFolded {
                delete(currentPot.Eligibles, p.ID)
            }
        } else {
            // å¦‚æœé€™å€‹äººé€™è¼ªæ²’å‡ºéŒ¢ (ä¸”ä¹‹å‰å°±æ²’éŒ¢äº†)ï¼Œä»–ä¹Ÿæ²’è³‡æ ¼è´é€™å€‹æ± 
            // æ³¨æ„ï¼šå¦‚æœæ˜¯ Check ç‹€æ…‹ (CurrentBet=0)ï¼Œéœ€è¦ä¿ç•™è³‡æ ¼å—ï¼Ÿ
            // é‚è¼¯ï¼šé€™è£¡è™•ç†çš„æ˜¯ã€Œé€™ä¸€è¼ªã€çš„ Side Potã€‚
            // å¦‚æœæ˜¯ Main Pot (Pots[0])ï¼Œå³ä½¿é€™ä¸€è¼ªæ²’å‡ºéŒ¢(å› ç‚ºå·²ç¶“ Allin)ï¼Œåªè¦ä¹‹å‰æœ‰å‡ºï¼Œè³‡æ ¼å°±åœ¨ã€‚
            // ç°¡å–®è§£æ³•ï¼šEligibles æ¡ç”¨ã€Œç¹¼æ‰¿åˆ¶ã€ï¼Œæ–° Pot è¤‡è£½èˆŠ Pot çš„åå–®ï¼Œç„¶å¾Œå‰”é™¤ã€‚
        }
    }
    
    currentPot.Amount += potTotal
}

// è¼”åŠ©ï¼šå°å­˜ä¸¦é–‹å•Ÿæ–° Pot
func (t *Table) closeCurrentPot() {
    lastPot := t.Pots[len(t.Pots)-1]
    lastPot.IsClosed = true
    
    // å»ºç«‹æ–°çš„ Side Pot
    newPot := &Pot{
        Amount: 0,
        // æ–° Pot çš„è³‡æ ¼åå–®ï¼Œåˆå§‹ç¹¼æ‰¿è‡ªä¸Šä¸€å€‹ Pot
        // å› ç‚ºå¦‚æœä½ æ²’è³‡æ ¼è´ Main Potï¼Œè‚¯å®šä¹Ÿæ²’è³‡æ ¼è´ Side Pot
        Eligibles: make(map[string]bool),
    }
    for pid := range lastPot.Eligibles {
        // åªæœ‰é‚£äº›ã€Œé‚„æœ‰ç±Œç¢¼ (CurrentBet > 0) ä¸”æ²’è“‹ç‰Œã€çš„äººï¼Œæ‰èƒ½é€²å…¥ä¸‹ä¸€ç´š Side Pot
        // ä½†æ­¤æ™‚ CurrentBet å·²ç¶“è¢«æ‰£é™¤éä¸€è¼ªäº†ã€‚
        // ç°¡å–®åˆ¤æ–·ï¼šå¦‚æœæ˜¯ All-in ä¸”ç±Œç¢¼æ­¸é›¶äº†ï¼Œå°±è¸¢å‡ºä¸‹ä¸€ç´šåå–®
        p := t.Players[pid]
        if p != nil && !p.IsFolded && p.CurrentBet > 0 {
            newPot.Eligibles[pid] = true
        }
    }
    
    t.Pots = append(t.Pots, newPot)
}
```

---

### å››ã€ çµç®—é‚è¼¯ (Showdown with Side Pots)

æœ‰äº† Side Potsï¼Œçµç®—æ™‚å°±ä¸èƒ½åªè·‘ä¸€æ¬¡æ¯”ç‰Œäº†ã€‚æˆ‘å€‘å¿…é ˆÂ **ã€Œå¾å¾Œå¾€å‰ (Last to First)ã€**Â çµç®—ã€‚

**ç‚ºä»€éº¼å¾å¾Œå¾€å‰ï¼Ÿ**Â å› ç‚º Side Pot 2 (æœ€ä¸Šé¢çš„) é€šå¸¸åªæœ‰ç±Œç¢¼æœ€å¤šçš„å…©å€‹äººçˆ­ã€‚å…ˆæŠŠé€™å€‹åˆ†äº†ï¼Œå†åˆ† Side Pot 1ï¼Œæœ€å¾Œåˆ† Main Potã€‚

**`table_showdown.go`**

Go

```
func (t *Table) distributePot(results []PlayerResult) {
    // results å·²ç¶“åŒ…å«æ‰€æœ‰äººçš„ç‰ŒåŠ› (HandStrength)ï¼Œä¸”æŒ‰ç‰ŒåŠ›æ’åºé(å¦‚æœæ²’æ’ï¼Œé€™è£¡è¦æ’)
    
    // å¾æœ€å¾Œä¸€å€‹ Side Pot é–‹å§‹éæ­·åˆ° Main Pot
    for i := len(t.Pots) - 1; i >= 0; i-- {
        pot := t.Pots[i]
        if pot.Amount == 0 { continue }
        
        fmt.Printf("Resolving Pot %d: $%d\n", i, pot.Amount)

        // 1. æ‰¾å‡ºé€™å€‹ Pot çš„åˆæ ¼è´å®¶
        var winners []*Player
        var bestStrength *HandStrength

        // éæ­·æ‰€æœ‰å·²æ’å¥½åºçš„ç©å®¶ (results[0] æ˜¯æœ€å¼·çš„)
        for _, res := range results {
            // æª¢æŸ¥æ˜¯å¦åœ¨ç™½åå–®å…§
            if !pot.Eligibles[res.PlayerID] {
                continue
            }
            
            // æ‰¾åˆ°ç¬¬ä¸€ä½åˆæ ¼è€…ï¼Œä»–å°±æ˜¯æœ€å¼·çš„ (å› ç‚º sorted)
            if bestStrength == nil {
                bestStrength = res.Strength
                winners = append(winners, t.Players[res.PlayerID])
                continue
            }
            
            // æª¢æŸ¥æœ‰æ²’æœ‰å¹³æ‰‹ (Split Pot)
            // å‡è¨­ Compare å›å‚³ 0 ä»£è¡¨å¹³æ‰‹
            if t.Evaluator.Compare(res.Strength, bestStrength) == 0 {
                winners = append(winners, t.Players[res.PlayerID])
            } else {
                // å› ç‚ºæ˜¯æ’åºéçš„ï¼Œå¦‚æœç•¶å‰é€™å€‹æ¯” best å¼±ï¼Œé‚£å¾Œé¢çš„è‚¯å®šæ›´å¼±ï¼Œç›´æ¥è·³å‡º
                break
            }
        }

        // 2. åˆ†éŒ¢
        if len(winners) > 0 {
            share := pot.Amount / int64(len(winners))
            remainder := pot.Amount % int64(len(winners))
            
            for idx, w := range winners {
                amount := share
                // é¤˜æ•¸è™•ç†ï¼šé€šå¸¸çµ¦ä½ç½®æœ€é å‰çš„ç©å®¶ (é è¿‘ Button çš„å·¦æ‰‹é‚Š)
                // é€™è£¡ç°¡åŒ–ï¼šçµ¦ç¬¬ä¸€å€‹è´å®¶
                if int64(idx) < remainder {
                    amount++
                }
                
                w.Chips += amount
                fmt.Printf("Player %s wins %d from Pot %d\n", w.ID, amount, i)
                
                // å»£æ’­è´éŒ¢è¨Šæ¯ (å‹•ç•«ç”¨)
                t.broadcastWin(w.ID, amount, i)
            }
        }
    }
}
```

---

### äº”ã€ å¯¦ä¾‹æ¼”ç·´ (Dry Run)

å‡è¨­å ´æ™¯ï¼š

- **Player A:**Â ç±Œç¢¼ 100, æ‰‹ç‰Œ KK
    
- **Player B:**Â ç±Œç¢¼ 500, æ‰‹ç‰Œ QQ
    
- **Player C:**Â ç±Œç¢¼ 1000, æ‰‹ç‰Œ AA
    

æµç¨‹ï¼š

1. **Action:**Â A All-in 100ã€‚B All-in 500ã€‚C Call 500ã€‚
    
2. **CurrentBets:**Â A=100, B=500, C=500ã€‚
    
3. **calculateSidePots:**
    
    - æ’åº All-in levels:Â `[100, 500]`Â (C é›–ç„¶æ²’ All-inï¼Œä½†ä»–å‡ºäº† 500ï¼Œä¸éæˆ‘å€‘åªçœ‹ All-in è€…çš„å€¼)ã€‚å…¶å¯¦é‚è¼¯ä¸Š C çš„ 500 æœƒåœ¨æœ€å¾Œä¸€æ­¥è¢«æ•ç²ã€‚
        
    - **Level 100:**
        
        - å¾ A, B, C å„æ‰£ 100ã€‚
            
        - Main Pot åŠ  300ã€‚Eligibles: {A, B, C}ã€‚
            
        - Close Main Potã€‚
            
        - A é¤˜é¡ 0ï¼Œå‰”é™¤å‡ºä¸‹ä¸€å€‹ Potã€‚
            
    - **Level 500:**
        
        - å¾ B, C å„æ‰£ 400 (500-100)ã€‚
            
        - Side Pot 1 åŠ  800ã€‚Eligibles: {B, C}ã€‚
            
        - Close Side Pot 1ã€‚
            
    - **å‰©é¤˜:**Â å¤§å®¶éƒ½æ‰£å…‰äº†ï¼Œæ²’å‰©ã€‚
        
4. **Showdown:**
    
    - ç‰ŒåŠ›æ’åº: C (AA) > A (KK) > B (QQ)ã€‚
        
    - **Resolve Side Pot 1 ($800):**
        
        - Eligibles: {B, C}ã€‚
            
        - C æœ€å¼·ï¼ŒC è´èµ° $800ã€‚
            
    - **Resolve Main Pot ($300):**
        
        - Eligibles: {A, B, C}ã€‚
            
        - C æœ€å¼·ï¼ŒC è´èµ° $300ã€‚
            
    - **Result:**Â C è´ $1100ã€‚B è¼¸å…‰ã€‚A è¼¸å…‰ã€‚é‚è¼¯æ­£ç¢ºã€‚
        

å†å‡è¨­ï¼šå¦‚æœ A æ‹¿çš„æ˜¯Â **AA**Â (æœ€å¼·)ï¼ŒC æ‹¿ KKï¼ŒB æ‹¿ QQã€‚

1. **Resolve Side Pot 1 ($800):**Â Eligibles {B, C}ã€‚C (KK) > B (QQ)ã€‚**C è´èµ° $800**ã€‚
    
2. **Resolve Main Pot ($300):**Â Eligibles {A, B, C}ã€‚A (AA) > C > Bã€‚**A è´èµ° $300**ã€‚
    
3. **Result:**Â A è®Š 300 (ç¿»ä¸‰å€)ã€‚C æ‹¿å› 800 (è´äº† B)ã€‚B è¼¸å…‰ã€‚é‚è¼¯æ­£ç¢ºã€‚
    

---

### å…­ã€ ä¸‹ä¸€æ­¥

è‡³æ­¤ï¼Œä½ çš„å¾Œç«¯å·²ç¶“å…·å‚™äº†è™•ç†æœ€è¤‡é›œè³‡é‡‘æµçš„èƒ½åŠ›ã€‚ æˆ‘å€‘å·²ç¶“å®Œæˆäº†ï¼š

1. Gateway & Protocol
    
2. Table FSM & Loop
    
3. Dealing & Blinds
    
4. Action Validation
    
5. Side Pot Calculation (Assets Security)
    

ä½ ç¾åœ¨å·²ç¶“æ“æœ‰ä¸€å€‹å¯ä»¥è·‘å®Œä¸€æ•´å±€éŠæˆ²çš„ Server Core äº†ï¼

**æ¥ä¸‹ä¾†çš„å»ºè­°æ­¥é©Ÿï¼š**Â ç›®å‰ä½ çš„ç³»çµ±æ˜¯ã€Œå–®æ©Ÿç‰ˆã€çš„ï¼ˆé›–ç„¶æœ‰ WebSocketï¼Œä½†æ‰€æœ‰æ•¸æ“šéƒ½åœ¨è¨˜æ†¶é«”ï¼‰ã€‚ ç‚ºäº†è®“ç³»çµ±èƒ½ä¸Šç·šé‹ç‡Ÿï¼Œä½ éœ€è¦è€ƒæ…®Â **ã€ŒæŒä¹…åŒ– (Persistence)ã€**ã€‚

**è«‹å•ä½ æƒ³è¦è¦åŠƒã€Œè³‡æ–™åº« Schema è¨­è¨ˆ (Hand History & User Balance)ã€ï¼Œé‚„æ˜¯å…ˆåšã€Œå‰ç«¯ JS ç°¡å–®æ¸¬è©¦è…³æœ¬ã€ä¾†é©—è­‰ç›®å‰å¯«å¥½çš„ä¼ºæœå™¨ï¼Ÿ**

å…ˆåšã€Œå‰ç«¯ JS ç°¡å–®æ¸¬è©¦è…³æœ¬ã€ä¾†é©—è­‰ç›®å‰å¯«å¥½çš„ä¼ºæœå™¨

é€™æ˜¯ä¸€å€‹éå¸¸å‹™å¯¦çš„æ±ºå®šã€‚ä¸ç”¨å¯« React/Vueï¼Œæˆ‘å€‘ç›´æ¥ç”¨ä¸€å€‹å–®ä¸€çš„ HTML æª”æ¡ˆ (`index.html`) åŒ…å«åŸç”Ÿ JavaScriptï¼Œå°±èƒ½æ¨¡æ“¬å¤šå€‹å®¢æˆ¶ç«¯ä¾†é©—è­‰ä¼ºæœå™¨é‚è¼¯ã€‚

é€™å€‹æ¸¬è©¦è…³æœ¬æœƒåŒ…å«ï¼š

1. **é€£ç·šé¢æ¿ï¼š**Â æ¨¡æ“¬ä¸åŒ Player ID ç™»å…¥ã€‚
    
2. **è¦–è¦ºåŒ–ç‰Œæ¡Œï¼š**Â é›–ç„¶æ˜¯ç”¨æ–‡å­—é¡¯ç¤ºï¼Œä½†èƒ½å³æ™‚çœ‹åˆ°æ‰€æœ‰äººçš„ç±Œç¢¼ã€ä½ç½®å’Œç‹€æ…‹ã€‚
    
3. **æ§åˆ¶å°ï¼š**Â ç™¼é€ Sit, Bet, Fold, All-in ç­‰æŒ‡ä»¤ã€‚
    
4. **Log è¦–çª—ï¼š**Â é¡¯ç¤ºä¼ºæœå™¨å›å‚³çš„åŸå§‹ JSONï¼Œæ–¹ä¾¿é™¤éŒ¯ã€‚
    

### ä¸€ã€ æ¸¬è©¦è…³æœ¬ä»£ç¢¼ (index.html)

è«‹å°‡ä»¥ä¸‹ä»£ç¢¼å­˜ç‚ºÂ `index.html`ï¼Œç„¶å¾Œç›´æ¥ç”¨ç€è¦½å™¨æ‰“é–‹ï¼ˆå»ºè­°æ‰“é–‹ 3 å€‹åˆ†é ï¼Œæ¨¡æ“¬ 3 å€‹ç©å®¶ï¼‰ã€‚

HTML

```
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Texas Hold'em Server Tester</title>
    <style>
        body { font-family: 'Segoe UI', monospace; background: #222; color: #eee; padding: 20px; display: flex; gap: 20px; }
        .panel { background: #333; padding: 20px; border-radius: 8px; width: 400px; }
        .game-view { flex-grow: 1; background: #1e1e1e; padding: 20px; border-radius: 8px; border: 1px solid #444; }
        
        input, button, select { padding: 8px; margin: 5px 0; width: 100%; box-sizing: border-box; }
        button { cursor: pointer; background: #4CAF50; color: white; border: none; font-weight: bold; }
        button.fold { background: #f44336; }
        button.check { background: #2196F3; }
        
        #log { height: 300px; overflow-y: scroll; background: #000; border: 1px solid #555; padding: 10px; font-size: 12px; margin-top: 20px; white-space: pre-wrap; color: #0f0; }
        
        .table-state { margin-bottom: 20px; padding: 10px; background: #2a2a2a; border: 1px dashed #666; }
        .player-row { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid #444; }
        .player-row.active { background: #3d3d00; color: #ffeb3b; }
        .player-row.me { font-weight: bold; color: #4CAF50; }
        
        .cards { letter-spacing: 2px; color: #ff9800; font-weight: bold; }
        .community { font-size: 20px; text-align: center; margin: 10px 0; color: #03a9f4; }
    </style>
</head>
<body>

    <div class="panel">
        <h3>1. é€£ç·šè¨­å®š</h3>
        <input type="text" id="wsUrl" value="ws://localhost:8080/ws" placeholder="WS URL">
        <input type="text" id="playerId" value="player_1" placeholder="Player ID">
        <input type="text" id="tableId" value="101" placeholder="Table ID">
        <button onclick="connect()">é€£ç·š (Connect)</button>
        <button onclick="disconnect()" style="background:#555">æ–·ç·š</button>

        <hr>
        <h3>2. ç©å®¶æ“ä½œ</h3>
        <div style="display:flex; gap:5px;">
            <input type="number" id="seatIdx" placeholder="Seat (0-8)" style="width:50%">
            <input type="number" id="buyIn" value="1000" placeholder="BuyIn Amount" style="width:50%">
        </div>
        <button onclick="sendAction('sit_down')">å…¥åº§ (Sit Down)</button>
        
        <hr>
        <h3>3. éŠæˆ²æŒ‡ä»¤</h3>
        <input type="number" id="betAmount" placeholder="Amount (for Bet/Raise/Sit)">
        
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
            <button class="check" onclick="sendAction('check')">Check</button>
            <button class="fold" onclick="sendAction('fold')">Fold</button>
            <button onclick="sendAction('call')">Call</button>
            <button onclick="sendAction('bet')">Bet / Raise</button>
        </div>
        
        <br>
        <button onclick="sendAction('start_game')" style="background: #9c27b0;">(Debug) å¼·åˆ¶é–‹å§‹</button>
    </div>

    <div class="game-view">
        <h2>Table Monitor</h2>
        
        <div class="community" id="communityCards">[ å…¬å…±ç‰Œå€åŸŸ ]</div>
        <div style="text-align:center; margin-bottom:10px;">
            Pot: <span id="potSize" style="color:#0f0; font-size:18px;">0</span> | 
            State: <span id="gameState">IDLE</span>
        </div>

        <div id="playersList" class="table-state">
            <div style="text-align:center; color:#888;">ç­‰å¾…é€£ç·š...</div>
        </div>

        <h3>Network Log</h3>
        <div id="log"></div>
    </div>

    <script>
        let ws;
        let myId = "";

        function log(msg, type = 'info') {
            const logDiv = document.getElementById('log');
            const color = type === 'out' ? '#0af' : (type === 'in' ? '#0f0' : '#888');
            const arrow = type === 'out' ? 'â†‘' : (type === 'in' ? 'â†“' : '-');
            logDiv.innerHTML += `<div style="color:${color}">${arrow} ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function connect() {
            const url = document.getElementById('wsUrl').value;
            myId = document.getElementById('playerId').value;
            const fullUrl = `${url}?player_id=${myId}`;

            ws = new WebSocket(fullUrl);

            ws.onopen = () => {
                log(`Connected as ${myId}`, 'sys');
                document.body.style.borderColor = '#4CAF50';
            };

            ws.onmessage = (event) => {
                log(event.data, 'in');
                const msg = JSON.parse(event.data);
                
                if (msg.type === 'game_state') {
                    renderTable(msg.payload); // æ ¹æ“šå¾Œç«¯ DTO çµæ§‹èª¿æ•´ key
                } else if (msg.type === 'error') {
                    alert("Error: " + msg.msg);
                }
            };

            ws.onclose = () => log("Disconnected", 'sys');
        }

        function disconnect() {
            if(ws) ws.close();
        }

        function sendAction(actionType) {
            if (!ws) return alert("Please connect first");
            
            const amount = parseInt(document.getElementById('betAmount').value) || 0;
            const seat = parseInt(document.getElementById('seatIdx').value) || 0;
            const buyIn = parseInt(document.getElementById('buyIn').value) || 0;
            const tableId = document.getElementById('tableId').value;

            // æ ¹æ“šä½ çš„ Protocol çµæ§‹çµ„è£ JSON
            const payload = {
                action: actionType,
                table_id: tableId,
                seat_idx: seat, // åƒ… SitDown ç”¨
                amount: (actionType === 'sit_down') ? buyIn : amount // è¤‡ç”¨ amount æ¬„ä½
            };

            log(JSON.stringify(payload), 'out');
            ws.send(JSON.stringify(payload));
        }

        // æ¸²æŸ“ç•«é¢é‚è¼¯
        function renderTable(data) {
            // æ³¨æ„ï¼šé€™è£¡çš„ data çµæ§‹å¿…é ˆå°æ‡‰ä½ çš„ GameStateUpdate DTO
            const publicState = data.public;   // å°æ‡‰ TablePublicState
            const privateState = data.private; // å°æ‡‰ PlayerPrivateInfo

            document.getElementById('potSize').innerText = publicState.pot;
            document.getElementById('gameState').innerText = publicState.state;
            document.getElementById('communityCards').innerText = 
                publicState.community_cards && publicState.community_cards.length > 0 
                ? publicState.community_cards.join("  ") 
                : "[ ç­‰å¾…ç¿»ç‰Œ ]";

            const listDiv = document.getElementById('playersList');
            listDiv.innerHTML = "";

            // ä½ çš„å¾Œç«¯ players é™£åˆ—
            if (publicState.players) {
                publicState.players.forEach(p => {
                    const isMe = p.id === myId;
                    const isActive = (p.seat_idx === publicState.current_pos);
                    const isButton = (p.seat_idx === publicState.button_pos);
                    
                    // å¦‚æœæ˜¯è‡ªå·±ï¼Œé¡¯ç¤ºæ‰‹ç‰Œ
                    let holeCards = "";
                    if (isMe && privateState.hole_cards) {
                        holeCards = `[ ${privateState.hole_cards.join(" ")} ]`;
                    }

                    const html = `
                        <div class="player-row ${isActive ? 'active' : ''} ${isMe ? 'me' : ''}">
                            <div style="width:30px">${isButton ? 'ğŸ…±ï¸' : ''}${p.seat_idx}</div>
                            <div style="width:100px">${p.id} ${isActive ? 'â³' : ''}</div>
                            <div style="width:80px">$${p.chips}</div>
                            <div style="width:80px">Bet: ${p.current_bet}</div>
                            <div style="width:80px">${p.status}</div>
                            <div class="cards">${holeCards}</div>
                        </div>
                    `;
                    listDiv.innerHTML += html;
                });
            }
        }
    </script>
</body>
</html>
```

### äºŒã€ é©—è­‰æµç¨‹ (Test Scenario)

è«‹æŒ‰ç…§é€™å€‹é †åºï¼Œé©—è­‰ä½ çš„ Go ä¼ºæœå™¨é‚è¼¯æ˜¯å¦æ­£ç¢ºï¼š

#### æº–å‚™å·¥ä½œ

1. å•Ÿå‹•ä½ çš„ Go Server (`go run main.go`)ã€‚
    
2. æ‰“é–‹ç€è¦½å™¨ï¼Œ**é–‹å•Ÿ 3 å€‹åˆ†é **ï¼Œåˆ†åˆ¥è¼‰å…¥é€™å€‹Â `index.html`ã€‚
    

#### ç¬¬ä¸€æ­¥ï¼šé€£ç·šèˆ‡å…¥åº§ (Connection & Sit Down)

- **Tab 1:**Â ID è¼¸å…¥Â `P1`ï¼ŒæŒ‰ã€Œé€£ç·šã€ã€‚Log é¡¯ç¤º Connectedã€‚
    
    - è¼¸å…¥ SeatÂ `0`, BuyInÂ `1000`ï¼ŒæŒ‰ã€Œå…¥åº§ã€ã€‚
        
    - _é©—è­‰ï¼š_Â ç•«é¢åˆ—è¡¨å‡ºç¾ P1ï¼Œç‹€æ…‹ç‚ºÂ `SittingOut`Â (æˆ–æ ¹æ“šä½ çš„é‚è¼¯ç›´æ¥æ˜¯ Playing)ã€‚
        
- **Tab 2:**Â ID è¼¸å…¥Â `P2`ï¼ŒæŒ‰ã€Œé€£ç·šã€ã€‚
    
    - è¼¸å…¥ SeatÂ `1`, BuyInÂ `1000`ï¼ŒæŒ‰ã€Œå…¥åº§ã€ã€‚
        
    - _é©—è­‰ï¼š_Â Tab 1 å’Œ Tab 2 çš„ç•«é¢æ‡‰è©²åŒæ­¥æ›´æ–°ï¼Œçœ‹åˆ° P1 å’Œ P2 éƒ½åœ¨åº§ã€‚
        
- **Tab 3:**Â ID è¼¸å…¥Â `P3`ï¼ŒæŒ‰ã€Œé€£ç·šã€ã€‚
    
    - è¼¸å…¥ SeatÂ `2`, BuyInÂ `2000`Â (å¤§ç±Œç¢¼æ¸¬è©¦ Side Pot ç”¨)ï¼ŒæŒ‰ã€Œå…¥åº§ã€ã€‚
        

#### ç¬¬äºŒæ­¥ï¼šé–‹å§‹éŠæˆ² (Start Game & Blinds)

- å¦‚æœä½ çš„ Server è¨­å®šæ¹Šæ»¿ 3 äººè‡ªå‹•é–‹å§‹ï¼Œç¾åœ¨æ‡‰è©²å·²ç¶“é–‹å±€ã€‚
    
- å¦‚æœæ²’æœ‰ï¼Œé»æ“ŠÂ `(Debug) å¼·åˆ¶é–‹å§‹`Â æŒ‰éˆ•ã€‚
    
- _é©—è­‰ï¼š_
    
    - **Public State:**Â Pot æ‡‰è©²è®Šæˆ 150 (å‡è¨­ SB 50, BB 100)ã€‚
        
    - **Private State:**Â æ¯å€‹åˆ†é æ‡‰è©²èƒ½çœ‹åˆ°**è‡ªå·±çš„å…©å¼µæ‰‹ç‰Œ**ï¼Œä½†çœ‹ä¸åˆ°åˆ¥äººçš„ï¼ˆé€™è­‰æ˜äº†è¦–è§’éæ¿¾æœ‰æ•ˆï¼‰ã€‚
        
    - **Active Player:**Â æ‡‰è©²è¼ªåˆ° Button çš„ä¸‹ä¸€å®¶ (UTG)ã€‚åå­—æ—é‚Šæ‡‰è©²æœ‰ â³ ç¬¦è™Ÿã€‚
        

#### ç¬¬ä¸‰æ­¥ï¼šä¸‹æ³¨æµç¨‹é©—è­‰ (Betting Loop)

- å‡è¨­ Tab 1 æ˜¯ UTGã€‚
    
- **Tab 1:**Â è¼¸å…¥ AmountÂ `100`ï¼ŒæŒ‰Â `Call`Â (è·Ÿæ³¨å¤§ç›²)ã€‚
    
    - _é©—è­‰ï¼š_Â Pot è®Šå¤§ï¼Œè¼ªåˆ° Tab 2ã€‚
        
- **Tab 2 (SB):**Â å·²ç¶“ä¸‹äº† 50ï¼Œè¼¸å…¥ AmountÂ `100`ï¼ŒæŒ‰Â `Call`Â (è£œé½Š)ã€‚
    
- **Tab 3 (BB):**Â å·²ç¶“ä¸‹äº† 100ï¼ŒæŒ‰Â `Check`ã€‚
    
- _é©—è­‰ï¼š_
    
    - ä¼ºæœå™¨ç‹€æ…‹æ‡‰è©²åˆ‡æ›åˆ°Â **FLOP**ã€‚
        
    - **Community Cards**Â æ‡‰è©²é¡¯ç¤º 3 å¼µç‰Œ (ä¾‹å¦‚Â `Ah Kd 5s`)ã€‚
        
    - Pot æ‡‰è©²æ˜¯ 300ã€‚
        
    - æ‰€æœ‰äººçš„ Current Bet æ­¸é›¶ã€‚
        

#### ç¬¬å››æ­¥ï¼šé‚Šæ± é‚è¼¯æ¸¬è©¦ (Side Pot Test)

é€™æ­¥æœ€é—œéµã€‚

- **Tab 1 (ç±Œç¢¼è¼ƒå°‘):**Â è¼¸å…¥Â `9999`ï¼ŒæŒ‰Â `Bet`Â (è§¸ç™¼ All-in)ã€‚
    
- **Tab 2 (ä¸­ç­‰ç±Œç¢¼):**Â è¼¸å…¥Â `9999`ï¼ŒæŒ‰Â `Call`Â (ä¹Ÿ All-inï¼Œä½†ä»–ç±Œç¢¼æ¯” P1 å¤š)ã€‚
    
- **Tab 3 (å¤§ç±Œç¢¼):**Â æŒ‰Â `Call`ã€‚
    
- æ­¤æ™‚å¾Œç«¯æ‡‰è©²è§¸ç™¼Â `calculateSidePots`ã€‚
    
- _é©—è­‰ï¼š_
    
    - è§€å¯Ÿ Log ä¸­çš„Â `game_state`ã€‚
        
    - ç¢ºä¿å‰ç«¯ Pot é¡¯ç¤ºæ­£ç¢ºã€‚å¦‚æœå‰ç«¯åªé¡¯ç¤ºç¸½ Potï¼Œä½ éœ€è¦çœ‹ Server çš„ Console Log ä¾†ç¢ºèªÂ `Pots`Â é™£åˆ—æ˜¯ä¸æ˜¯Â `[MainPot, SidePot1]`ã€‚
        

### ä¸‰ã€ å¸¸è¦‹çš„ Bug æª¢æŸ¥é»

åœ¨ä½¿ç”¨é€™å€‹è…³æœ¬æ™‚ï¼Œè«‹ç‰¹åˆ¥æ³¨æ„ä»¥ä¸‹å¹¾é»ï¼š

1. **JSON è§£æéŒ¯èª¤ï¼š**Â å¦‚æœå¾Œç«¯çš„ struct field æ²’æœ‰åŠ Â `` `json:"xxx"` ``Â tagï¼Œå‰ç«¯æœƒæ”¶åˆ°å¤§å¯«çš„ Key (å¦‚Â `Amount`)ï¼Œå°è‡´å‰ç«¯Â `msg.amount`Â è®€ä¸åˆ°ã€‚
    
2. **å»£æ’­æ²’è§¸ç™¼ï¼š**Â æ“ä½œäº†æŒ‰éˆ•ï¼ŒServer æ”¶åˆ°äº†ï¼Œä½†ç•«é¢æ²’è®Šã€‚é€™é€šå¸¸æ˜¯Â `broadcastState()`Â æ²’åœ¨Â `applyAction`Â å¾Œè¢«å‘¼å«ã€‚
    
3. **é‡‘é¡å–®ä½ï¼š**Â ç¢ºä¿å‰ç«¯å‚³çš„Â `100`Â æ˜¯æ•´æ•¸ã€‚å¦‚æœå¾Œç«¯ç”¨Â `float`Â è™•ç†é‡‘é¡æœƒæ˜¯å¤§å¿Œï¼ˆæœƒæœ‰ç²¾åº¦å•é¡Œï¼‰ï¼Œè«‹å…¨ç¨‹ç”¨Â `int64`Â (åˆ†/å˜)ã€‚
    

ç¾åœ¨ï¼Œä½ å¯ä»¥è©¦è‘—æŠŠä½ çš„ Go Server è·‘èµ·ä¾†ï¼Œç”¨é€™å€‹è…³æœ¬å°æ¥çœ‹çœ‹äº†ï¼å¦‚æœé€£ç·šæœ‰å•é¡Œï¼Œè«‹å‘Šè¨´æˆ‘ Server çš„éŒ¯èª¤è¨Šæ¯ã€‚